module Ruby
  module Rego
    VERSION: String

    type position = {
      line: Integer,
      column: Integer,
      offset: Integer?,
      length: Integer?
    }

    module ErrorFormatting
      def self.format_details: (Hash[Symbol, untyped]) -> String
    end

    class Location
      attr_reader line: Integer
      attr_reader column: Integer
      attr_reader offset: Integer?
      attr_reader length: Integer?

      def self.from: (Location | position) -> Location
      def initialize: (line: Integer, column: Integer, ?offset: Integer?, ?length: Integer?) -> void
      def to_s: () -> String
    end

    class Error < StandardError
      attr_reader location: Location?

      def initialize: (?String message, location: Location?) -> void

      private

      def compose_message: (String? message) -> String
    end

    class LexerError < Error
      attr_reader line: Integer
      attr_reader column: Integer

      def initialize: (String message, line: Integer, column: Integer, offset: Integer?, length: Integer?) -> void
    end

    class ParserError < Error
      attr_reader line: Integer
      attr_reader column: Integer
      attr_reader context: String?

      def initialize: (String message, location: Location, context: String?) -> void
      def self.from_position: (String message, position: position | Location, context: String?) -> ParserError
    end

    class EvaluationError < Error
      attr_reader rule: untyped

      def initialize: (String message, rule: untyped, ?location: Location?) -> void
    end

    class TypeError < Error
      attr_reader expected: untyped
      attr_reader actual: untyped
      attr_reader context: String?

      def initialize: (String message, expected: untyped, actual: untyped, context: String?, location: Location?) -> void
    end

    class ObjectKeyConflictError < Error
    end

    class UnificationError < Error
      attr_reader pattern: untyped
      attr_reader value: untyped

      def initialize: (String message, pattern: untyped, value: untyped, location: Location?) -> void
    end

    class Value
      TYPE_NAME: String

      def self.from_ruby: (untyped) -> Value
      def initialize: (?untyped value) -> void
      attr_reader value: untyped
      def truthy?: () -> bool
      def to_ruby: () -> untyped
      def type_name: () -> String
      def undefined?: () -> bool
      def object_key: () -> untyped
      def fetch_reference: (untyped key) -> Value
      def ==: (untyped) -> bool
      def eql?: (untyped) -> bool
      def hash: () -> Integer

      private

      def self.build_value: (untyped) -> Value?
      def self.build_simple_value: (untyped) -> Value?
      def self.build_composite_value: (untyped) -> Value?
    end

    class StringValue < Value
      TYPE_NAME: String

      def initialize: (String value) -> void
    end

    class NumberValue < Value
      TYPE_NAME: String

      def initialize: (Numeric value) -> void
    end

    class BooleanValue < Value
      TYPE_NAME: String

      def initialize: (bool value) -> void
      def truthy?: () -> bool
    end

    class NullValue < Value
      TYPE_NAME: String

      def initialize: () -> void
      def truthy?: () -> bool
    end

    class UndefinedValue < Value
      TYPE_NAME: String
      UNDEFINED: untyped

      def initialize: () -> void
      def truthy?: () -> bool
      def to_ruby: () -> untyped
      def object_key: () -> UndefinedValue
    end

    class ArrayValue < Value
      TYPE_NAME: String

      def initialize: (Array[untyped] elements) -> void
      def fetch_index: (Integer index) -> Value
      def fetch_reference: (untyped key) -> Value
      def to_ruby: () -> Array[untyped]
    end

    class ObjectValue < Value
      TYPE_NAME: String

      def initialize: (Hash[untyped, untyped] pairs) -> void
      def fetch: (untyped key) -> Value
      def fetch_reference: (untyped key) -> Value
      def to_ruby: () -> Hash[untyped, untyped]

      private

      def fetch_by_symbol_key: (Symbol key) -> Value
      def normalize_pairs: (Hash[untyped, untyped] pairs) -> Hash[untyped, Value]
      def ensure_unique_key: (untyped normalized_key, Hash[untyped, untyped] key_sources, untyped key) -> void
    end

    class SetValue < Value
      TYPE_NAME: String

      def initialize: (Set[untyped] | Array[untyped] elements) -> void
      def include?: (untyped value) -> bool
      def to_ruby: () -> Set[untyped]
    end

    module Builtins
      module Base
        def self.assert_arity: (Array[untyped] args, Integer expected, ?name: String?) -> void
        def self.assert_type: (untyped value, expected: Class | Array[Class], ?context: String?) -> void
        def self.to_ruby: (untyped value) -> untyped
        def self.to_value: (untyped value) -> Value

        private

        def self.normalize_expected: (Class | Array[Class]) -> Array[Class]
        def self.raise_type_error: (expected: String, actual: String, ?context: String?) -> void
      end

      class BuiltinRegistry
        @builtins: Hash[String, untyped]
        Entry: untyped

        def initialize: () -> void
        def self.instance: () -> BuiltinRegistry
        def register: (String | Symbol name, Integer arity) { (*untyped) -> untyped } -> void
        def call: (String | Symbol name, Array[untyped] args) -> Value
        def registered?: (String | Symbol name) -> bool

        private

        def normalize_name: (String | Symbol name) -> String
        def validate_arity: (Integer arity) -> void
        def fetch_entry: (String builtin_name) -> untyped
        def invoke: (untyped entry, untyped args) -> Value
        def ensure_array_args: (untyped args, String builtin_name) -> Array[untyped]
      end

      module Types
        TYPE_PREDICATES: Hash[String, Symbol]

        def self.register!: () -> BuiltinRegistry
        def self.is_string: (Value value) -> BooleanValue
        def self.is_number: (Value value) -> BooleanValue
        def self.is_boolean: (Value value) -> BooleanValue
        def self.is_array: (Value value) -> BooleanValue
        def self.is_object: (Value value) -> BooleanValue
        def self.is_set: (Value value) -> BooleanValue
        def self.is_null: (Value value) -> BooleanValue

        private

        def self.register_predicate: (BuiltinRegistry registry, String name, Symbol handler) -> void
      end

      module Aggregates
        AGGREGATE_FUNCTIONS: Hash[String, Symbol]

        def self.register!: () -> BuiltinRegistry
        def self.count: (Value collection) -> NumberValue
        def self.sum: (Value array) -> NumberValue
        def self.max: (Value array) -> NumberValue
        def self.min: (Value array) -> NumberValue
        def self.all: (Value array) -> BooleanValue
        def self.any: (Value array) -> BooleanValue

        private

        def self.register_function: (BuiltinRegistry registry, String name, Symbol handler) -> void
        def self.numeric_array: (Value array, name: String) -> Array[Numeric]
        def self.ensure_non_empty: (Array[Numeric] numbers, name: String) -> void
      end
    end

    class Environment
      RESERVED_BINDINGS: Hash[String, Symbol]
      RESERVED_NAMES: Array[String]

      attr_reader input: Value
      attr_reader data: Value
      attr_reader rules: Hash[untyped, untyped]

      def initialize: (input: untyped, data: untyped, rules: Hash[untyped, untyped]) -> void
      def push_scope: () -> Environment
      def pop_scope: () -> void
      def bind: (String | Symbol name, untyped value) -> Value
      def lookup: (String | Symbol name) -> Value
      def resolve_reference: (untyped ref) -> Value
      def reference_key_for: (AST::Variable variable) -> untyped
      def with_bindings: (Hash[String | Symbol, untyped] bindings) { () -> untyped } -> untyped

      private

      attr_reader locals: Array[Hash[String, Value]]
      def resolve_base: (untyped base) -> Value
      def resolve_path_segment: (Value current, untyped segment) -> Value
      def resolve_reference_path: (Value current, Array[untyped] path) -> Value
      def extract_reference_key: (untyped segment) -> untyped
      def resolve_reference_variable: (untyped value) -> untyped
    end

    class Unifier
      def initialize: () -> void
      def unify: (untyped pattern, untyped value, Environment env) -> Array[Hash[String, Value]]
      def unify_array: (Array[untyped] pattern_elems, untyped value_array, Environment env, ?Hash[String, Value] bindings) -> Array[Hash[String, Value]]
      def unify_object: (Array[[untyped, untyped]] pattern_pairs, untyped value_obj, Environment env, ?Hash[String, Value] bindings) -> Array[Hash[String, Value]]

      private

      def unify_with_bindings: (untyped pattern, untyped value, Environment env, Hash[String, Value] bindings) -> Array[Hash[String, Value]]
      def structured_unification: (untyped pattern, Value resolved_value, Environment env, Hash[String, Value] bindings) -> Array[Hash[String, Value]]?
      def apply_unification: (untyped pattern, Value resolved_value, Environment env, Hash[String, Value] bindings) -> Array[Hash[String, Value]]
      def reduce_array_bindings: (Array[untyped] pattern_elems, Array[Value] elements, Environment env, Hash[String, Value] bindings) -> Array[Hash[String, Value]]
      def reduce_object_pairs: (Array[[untyped, untyped]] pattern_pairs, Hash[untyped, Value] object_values, Environment env, Hash[String, Value] bindings) -> Array[Hash[String, Value]]
      def unify_object_pair: (untyped key_pattern, untyped value_pattern, Hash[untyped, Value] object_values, Environment env, Hash[String, Value] bindings) -> Array[Hash[String, Value]]
      def unify_object_candidate: (untyped candidate_key, untyped key_pattern, untyped value_pattern, Hash[untyped, Value] object_values, Environment env, Hash[String, Value] bindings) -> Array[Hash[String, Value]]
      def bind_key_variable: (untyped key_pattern, untyped candidate_key, Hash[String, Value] bindings, Environment env) -> Hash[String, Value]?
    end

    module Unifier::Helpers
      def self.scalar_pattern_value: (untyped pattern, Environment env) -> Value
      def self.value_for_pattern: (untyped pattern, Environment env) -> Value
      def self.normalize_value: (untyped value, Environment env) -> Value
      def self.normalize_array: (untyped value) -> Array[Value]?
      def self.normalize_elements: (Array[untyped] elements) -> Array[Value]?
      def self.object_pairs: (untyped value) -> Hash[untyped, untyped]?
      def self.normalize_key: (untyped key) -> untyped
      def self.normalize_object: (untyped value) -> Hash[untyped, Value]?
      def self.bound_value_for: (String name, Hash[String, Value] bindings, Environment env) -> Value?
      def self.merge_bindings: (Hash[String, Value] bindings, Hash[String, Value] additions) -> Hash[String, Value]?
      def self.unify_variable: (AST::Variable variable, Value value, Environment env, Hash[String, Value] bindings) -> Array[Hash[String, Value]]
      def self.variable_candidate_keys: (AST::Variable key_pattern, Array[untyped] keys, Environment env, Hash[String, Value] bindings) -> Array[untyped]
      def self.bind_key_variable: (untyped key_pattern, untyped candidate_key, Hash[String, Value] bindings, Environment env) -> Hash[String, Value]?
      def self.candidate_keys_for: (untyped key_pattern, Array[untyped] keys, Environment env, Hash[String, Value] bindings) -> Array[untyped]
      def self.match_scalar: (untyped pattern, Value resolved_value, Environment env, Hash[String, Value] bindings) -> Array[Hash[String, Value]]
    end

    class Result
      attr_reader value: Value
      attr_reader bindings: Hash[String, Value]
      attr_reader success: bool
      attr_reader errors: Array[untyped]

      def initialize: (value: untyped, success: bool, ?bindings: Hash[String | Symbol, untyped], ?errors: Array[untyped]) -> void
      def success?: () -> bool
      def undefined?: () -> bool
      def to_h: () -> Hash[Symbol, untyped]

      private

      def add_bindings: (Hash[String | Symbol, untyped] bindings) -> void
    end

    class Evaluator
      attr_reader module_node: AST::Module
      attr_reader environment: Environment

      def initialize: (AST::Module ast_module, input: untyped, data: untyped) -> void
      def evaluate: (?untyped query) -> Result

      private

      attr_reader expression_evaluator: Evaluator::ExpressionEvaluator
      attr_reader rule_evaluator: Evaluator::RuleEvaluator

      def evaluate_rules: () -> Hash[untyped, untyped]
      def evaluate_query: (untyped query) -> Value
      def build_evaluators: (Hash[String, Array[AST::Rule]] rules_by_name, Array[String] package_path) -> [Evaluator::ExpressionEvaluator, Evaluator::RuleEvaluator]
      def build_expression_evaluator: (Evaluator::RuleValueProvider rule_value_provider, Array[String] package_path) -> Evaluator::ExpressionEvaluator
      def build_rule_evaluator: (Evaluator::ExpressionEvaluator expression_evaluator, Evaluator::RuleValueProvider rule_value_provider) -> Evaluator::RuleEvaluator
      def eval_node: (untyped node) -> Value
    end

    class Evaluator::QueryNodeBuilder
      def initialize: (untyped query) -> void
      def build: () -> untyped

      private

      attr_reader query: untyped
      def reference_from_string: () -> AST::Reference
    end

    class Evaluator::RuleValueProvider
      def initialize: (rules_by_name: Hash[String, Array[AST::Rule]]) -> void
      def attach: (Evaluator::RuleEvaluator rule_evaluator) -> void
      def value_for: (String name) -> Value
      def rule_defined?: (String name) -> bool

      private

      attr_reader rule_evaluator: Evaluator::RuleEvaluator?
      attr_reader rules_by_name: Hash[String, Array[AST::Rule]]
    end

    class Evaluator::ReferenceResolver
      def initialize: (environment: Environment, package_path: Array[String], rule_value_provider: Evaluator::RuleValueProvider) -> void
      def resolve: (untyped ref) -> Value

      private

      def resolve_rule_reference: (AST::Reference ref) -> Value?
      def rule_reference: (Array[AST::RefArg] path) -> [String, Array[AST::RefArg]]?
      def resolve_rule_value: (String rule_name, Array[AST::RefArg] remaining_path) -> Value
      def package_rule_reference: (Array[untyped] keys, Array[AST::RefArg] path) -> [String, Array[AST::RefArg]]?
      def direct_rule_reference: (Array[untyped] keys, Array[AST::RefArg] path) -> [String, Array[AST::RefArg]]?
      def resolve_reference_path: (Value current, Array[AST::RefArg] path) -> Value
      def resolve_path_segment: (Value current, AST::RefArg segment) -> Value
      def valid_reference_keys: (Array[AST::RefArg] path) -> Array[untyped]?
      def reference_keys: (Array[AST::RefArg] path) -> Array[untyped]
      def package_match?: (Array[untyped] keys) -> bool

      private

      attr_reader environment: Environment
      attr_reader key_resolver: Evaluator::ReferenceKeyResolver
      attr_reader rules_by_name: Hash[String, Array[AST::Rule]]
      attr_reader package_path: Array[String]
      attr_reader rule_value_provider: Evaluator::RuleValueProvider
    end

    class Evaluator::ReferenceKeyResolver
      def initialize: (environment: Environment) -> void
      def resolve: (untyped segment) -> untyped

      private

      attr_reader environment: Environment
      def resolve_segment: (untyped segment) -> untyped
    end

    class Evaluator::ExpressionEvaluator
      PRIMITIVE_TYPES: Array[Class]
      NODE_EVALUATORS: Array[[Class, ^(untyped, Evaluator::ExpressionEvaluator) -> Value]]

      include Evaluator::AssignmentSupport

      def initialize: (environment: Environment, reference_resolver: Evaluator::ReferenceResolver, ?unifier: Unifier) -> void
      def evaluate: (untyped node) -> Value
      def eval_with_unification: (untyped node, ?Environment env) -> Enumerator[Hash[String, Value]]

      private

      def evaluate_variable: (AST::Variable node) -> Value
      def evaluate_reference: (AST::Reference node) -> Value
      def evaluate_array_literal: (AST::ArrayLiteral node) -> Value
      def evaluate_object_literal: (AST::ObjectLiteral node) -> Value
      def evaluate_set_literal: (AST::SetLiteral node) -> Value
      def evaluate_binary_op: (AST::BinaryOp node) -> Value
      def evaluate_unary_op: (AST::UnaryOp node) -> Value
      def handle_unification_operator: (AST::BinaryOp node, Environment env, Enumerator::Yielder yielder) -> void
      def yield_assignment_bindings: (AST::BinaryOp node, Environment env, Enumerator::Yielder yielder) -> void
      def yield_unification_bindings: (AST::BinaryOp node, Environment env, Enumerator::Yielder yielder) -> void
      def yield_truthy_bindings: (untyped node, Enumerator::Yielder yielder) -> void
      def raise_unknown_node: (untyped node) -> Value

      attr_reader environment: Environment
      attr_reader reference_resolver: Evaluator::ReferenceResolver
      attr_reader object_literal_evaluator: Evaluator::ObjectLiteralEvaluator
      attr_reader dispatch: Evaluator::ExpressionDispatch
      attr_reader unifier: Unifier

    end

    class Evaluator::ObjectLiteralEvaluator
      def initialize: (expression_evaluator: Evaluator::ExpressionEvaluator) -> void
      def evaluate: (AST::ObjectLiteral node) -> Value

      private

      attr_reader expression_evaluator: Evaluator::ExpressionEvaluator
      def build_pairs: (AST::ObjectLiteral node) -> (Hash[Object, Value] | UndefinedValue)
      def evaluate_key: (untyped key_node) -> untyped
      def resolve_pair: (untyped key_node, untyped value_node) -> (Array[untyped] | UndefinedValue)
    end

    module Evaluator::AssignmentSupport
      private

      def evaluate: (untyped node) -> Value
      def environment: () -> Environment
      def unifier: () -> Unifier
      def evaluate_assignment: (AST::BinaryOp node) -> Value
      def evaluate_unification: (AST::BinaryOp node) -> Value
      def unification_binding_sets: (AST::BinaryOp node, Environment env) -> Array[Hash[String, Value]]
      def unification_result: (AST::BinaryOp node, Environment env) -> [Array[Hash[String, Value]], Value]
      def apply_bindings: (Hash[String, Value] bindings) -> Hash[String, Value]
    end

    class Evaluator::ExpressionDispatch
      def initialize: (primitive_types: Array[Class], node_evaluators: Array[[Class, ^(untyped, Evaluator::ExpressionEvaluator) -> Value]]) -> void
      def primitive_value: (untyped node) -> Value?
      def dispatch_node: (untyped node, Evaluator::ExpressionEvaluator evaluator) -> Value?

      private

      attr_reader primitive_types: Array[Class]
      attr_reader node_evaluators: Array[[Class, ^(untyped, Evaluator::ExpressionEvaluator) -> Value]]
      attr_reader handler_cache: Hash[Class, (^(untyped, Evaluator::ExpressionEvaluator) -> Value)?]
      def handler_for: (untyped node) -> (^(untyped, Evaluator::ExpressionEvaluator) -> Value)?
    end

    class Evaluator::RuleEvaluator
      def initialize: (environment: Environment, expression_evaluator: Evaluator::ExpressionEvaluator) -> void
      def evaluate_group: (Array[AST::Rule] rules) -> Value
      def evaluate_rule: (AST::Rule rule) -> untyped

      private

      def evaluate_partial_set_rules: (Array[AST::Rule] rules) -> Value
      def evaluate_partial_object_rules: (Array[AST::Rule] rules) -> Value
      def partial_object_pairs: (Array[AST::Rule] rules) -> Hash[Object, Value]
      def evaluate_complete_rules: (Array[AST::Rule] rules) -> Value
      def evaluate_non_default_rules: (Array[AST::Rule] rules) -> Value?
      def evaluate_partial_object_value: (untyped head) -> untyped
      def evaluate_complete_rule_value: (untyped head) -> Value
      def body_succeeds?: (Array[untyped]? body) -> bool
      def query_literal_truthy?: (untyped literal) -> bool
      def some_decl_truthy?: (AST::SomeDecl literal) -> bool
      def evaluate_rule_value: (untyped head) -> Value
      def rule_body_values: (AST::Rule rule) -> Array[untyped]
      def each_body_solution: (Array[untyped] literals, ?Integer index, ?Hash[String, Value] bindings) -> Enumerator[Hash[String, Value]]
      def yield_body_solutions: (Enumerator::Yielder yielder, Array[untyped] literals, Integer index, Hash[String, Value] bindings) -> void
      def each_literal_solution: (untyped literal) -> Enumerator[Hash[String, Value]]
      def each_some_solution: (AST::SomeDecl literal) -> Enumerator[Hash[String, Value]]
      def each_array_binding: (Array[AST::Variable] variables, ArrayValue collection_value) -> Enumerator[Hash[String, Value]]
      def each_set_binding: (Array[AST::Variable] variables, SetValue collection_value) -> Enumerator[Hash[String, Value]]
      def each_object_binding: (Array[AST::Variable] variables, ObjectValue collection_value) -> Enumerator[Hash[String, Value]]
      def bindings_for: (AST::Variable variable, untyped value) -> Hash[String, Value]
      def merge_bindings: (Hash[String, Value] existing, Hash[String, Value] additions) -> Hash[String, Value]?

      attr_reader environment: Environment
      attr_reader expression_evaluator: Evaluator::ExpressionEvaluator
    end

    module Evaluator::OperatorEvaluator
      EQUALITY_OPERATORS: Hash[Symbol, ^(untyped, untyped) -> Value]
      LOGICAL_OPERATORS: Hash[Symbol, ^(Value, Value) -> Value]
      COMPARISON_OPERATORS: Hash[Symbol, ^(untyped, untyped) -> bool]
      ARITHMETIC_OPERATORS: Hash[Symbol, ^(untyped, untyped) -> untyped]
      UNARY_OPERATORS: Hash[Symbol, ^(Value) -> Value]

      def self.apply: (Symbol operator, Value left, Value right) -> Value
      def self.apply_unary: (Symbol operator, Value operand) -> Value
      def self.apply_logical: (Symbol operator, Value left, Value right) -> Value?
      def self.apply_comparison: (Symbol operator, Value left, Value right) -> Value?
      def self.apply_arithmetic: (Symbol operator, Value left, Value right) -> Value?
      def self.compare_values: (Value left, Value right) { (untyped, untyped) -> bool } -> Value
      def self.comparable?: (untyped left_value, untyped right_value) -> bool
      def self.arithmetic_values: (Symbol operator, Value left, Value right) { (untyped, untyped) -> untyped } -> Value
      def self.numeric_value: (Value value) -> Numeric?
      def self.division_by_zero?: (Symbol operator, Numeric right_value) -> bool
    end

    module TokenType
      PACKAGE: Symbol
      IMPORT: Symbol
      AS: Symbol
      DEFAULT: Symbol
      IF: Symbol
      CONTAINS: Symbol
      SOME: Symbol
      IN: Symbol
      EVERY: Symbol
      NOT: Symbol
      WITH: Symbol
      ELSE: Symbol
      TRUE: Symbol
      FALSE: Symbol
      NULL: Symbol
      DATA: Symbol
      INPUT: Symbol

      ASSIGN: Symbol
      EQ: Symbol
      NEQ: Symbol
      LT: Symbol
      LTE: Symbol
      GT: Symbol
      GTE: Symbol
      PLUS: Symbol
      MINUS: Symbol
      STAR: Symbol
      SLASH: Symbol
      PERCENT: Symbol
      PIPE: Symbol
      AMPERSAND: Symbol
      UNIFY: Symbol

      LPAREN: Symbol
      RPAREN: Symbol
      LBRACKET: Symbol
      RBRACKET: Symbol
      LBRACE: Symbol
      RBRACE: Symbol
      DOT: Symbol
      COMMA: Symbol
      SEMICOLON: Symbol
      COLON: Symbol
      UNDERSCORE: Symbol

      STRING: Symbol
      NUMBER: Symbol
      RAW_STRING: Symbol
      IDENT: Symbol

      EOF: Symbol
      NEWLINE: Symbol
      COMMENT: Symbol

      KEYWORDS: Array[Symbol]
      OPERATORS: Array[Symbol]
      DELIMITERS: Array[Symbol]
      LITERALS: Array[Symbol]
      SPECIALS: Array[Symbol]

      def self.keyword?: (Symbol type) -> bool
      def self.operator?: (Symbol type) -> bool
      def self.literal?: (Symbol type) -> bool
    end

    class Token
      attr_reader type: Symbol
      attr_reader value: untyped
      attr_reader location: Location?

      def initialize: (type: Symbol, ?value: untyped, ?location: Location?) -> void
      def keyword?: () -> bool
      def operator?: () -> bool
      def literal?: () -> bool
      def to_s: () -> String
    end

    class Lexer
      KEYWORDS: Hash[String, Symbol]
      SINGLE_CHAR_TOKENS: Hash[String, Symbol]
      NEWLINE_CHARS: Array[String]
      WHITESPACE_CHARS: Array[String]
      EXPONENT_CHARS: Array[String]
      SIGN_CHARS: Array[String]
      IDENTIFIER_START: Regexp
      IDENTIFIER_PART: Regexp
      DIGIT: Regexp
      HEX_DIGIT: Regexp

      def initialize: (String source) -> void
      def tokenize: () -> Array[Token]

      private

      def next_token: () -> Token
      def eof_token: () -> Token
      def simple_token_for: (String char) -> Token?
      def read_colon_or_assign: () -> Token
      def read_equal_or_unify: () -> Token
      def read_not_equal: () -> Token
      def read_lt_or_lte: () -> Token
      def read_gt_or_gte: () -> Token
      def skip_whitespace: () -> void
      def skip_comment: () -> void
      def read_number: () -> Token
      def read_string: () -> Token
      def read_raw_string: () -> Token
      def read_newline: () -> Token
      def read_identifier: () -> Token
      def read_digits: () -> String
      def read_escape_sequence: (position backslash_position) -> String
      def read_unicode_escape: () -> String
      def parse_number: (String buffer, position start) -> Numeric
      def advance: () -> String
      def advance_line_break: () -> String
      def advance_newline: () -> String
      def increment_line: (Integer count) -> void
      def increment_position: (Integer count) -> void
      def peek: (?Integer distance) -> String?
      def match?: (String expected) -> bool
      def current_char: () -> String?
      def eof?: () -> bool
      def capture_position: () -> position
      def build_token: (Symbol type, untyped value, position start) -> Token
      def identifier_start?: (String? char) -> bool
      def identifier_part?: (String? char) -> bool
      def digit?: (String? char) -> bool
      def hex_digit?: (String? char) -> bool
      def whitespace?: (String? char) -> bool
      def newline?: (String? char) -> bool
      def exponent_start?: () -> bool
      def span_length_from: (position start) -> Integer
      def raise_unterminated_string: (position start) -> bot
      def raise_unterminated_raw_string: (position start) -> bot
      def raise_unexpected_eof: () -> bot
      def raise_error: (String message, position position, length: Integer?) -> bot

      private

      attr_reader source: String
      attr_reader position: Integer
      attr_reader line: Integer
      attr_reader column: Integer
      attr_reader offset: Integer
    end

    class Parser
      IDENTIFIER_TOKEN_TYPES: Array[Symbol]
      IDENTIFIER_TOKEN_NAMES: Hash[Symbol, String]
      PACKAGE_PATH_TOKEN_TYPES: Array[Symbol]
      IMPORT_PATH_TOKEN_TYPES: Array[Symbol]
      BINARY_OPERATOR_MAP: Hash[Symbol, Symbol]
      UNARY_OPERATOR_MAP: Hash[Symbol, Symbol]
      PRIMARY_PARSERS: Hash[Symbol, Symbol]

      @tokens: Array[Token]
      @current: Integer
      @errors: Array[ParserError]

      def initialize: (Array[Token] tokens) -> void
      def parse: () -> AST::Module

      private

      def tokens: () -> Array[Token]
      def current_token: () -> Token
      def peek: (?Integer distance) -> Token
      def advance: () -> Token
      def consume: (Symbol type, ?String message) -> Token
      def match?: (*Symbol types) -> bool
      def pipe_token?: () -> bool
      def rbrace_token?: () -> bool
      def newline_token?: () -> bool
      def consume_newlines: () -> void
      def at_end?: () -> bool
      def parse_error: (String message) -> bot
      def synchronize: () -> void
      def parse_module: () -> AST::Module
      def parse_statement: (Array[AST::Import] imports, Array[AST::Rule] rules) -> void
      def parse_package: () -> AST::Package
      def parse_import: () -> AST::Import
      def parse_import_alias: () -> String?
      def parse_rule: () -> AST::Rule
      def consume_default_keyword: () -> Token?
      def parse_rule_name: () -> String
      def mark_default_head: (Hash[Symbol, untyped] head) -> Hash[Symbol, untyped]
      def parse_default_value: (Token? default_token, Hash[Symbol, untyped] head) -> AST::expression?
      def parse_non_default_body: (Token? default_token) -> Array[AST::query_literal]?
      def parse_rule_definition: (Token? default_token, Hash[Symbol, untyped] head) -> Hash[Symbol, untyped]
      def parse_else_clause_for_definition: (Token? default_token) -> Hash[Symbol, untyped]?
      def validate_rule_definition: (Token? default_token, Hash[Symbol, untyped] head, Hash[Symbol, untyped] definition) -> void
      def parse_else_clause_if_present: () -> Hash[Symbol, untyped]?
      def build_rule_node: (name: String, head: Hash[Symbol, untyped], name_token: Token, definition: Hash[Symbol, untyped]) -> AST::Rule
      def parse_rule_head: (String name, Token name_token) -> Hash[Symbol, untyped]
      def parse_contains_rule_head: (String name, Token name_token) -> Hash[Symbol, untyped]
      def parse_function_rule_head: (String name, Token name_token) -> Hash[Symbol, untyped]
      def parse_bracket_rule_head: (String name, Token name_token) -> Hash[Symbol, untyped]
      def parse_partial_object_rule_head: (String name, Token name_token, AST::expression key) -> Hash[Symbol, untyped]
      def build_rule_head: (Symbol type, String name, Token name_token, **untyped attrs) -> Hash[Symbol, untyped]
      def parse_rule_head_args: () -> Array[AST::expression]
      def parse_rule_head_key: () -> AST::expression
      def parse_rule_value: () -> AST::expression?
      def parse_rule_body: () -> Array[AST::query_literal]
      def parse_braced_rule_body: () -> Array[AST::query_literal]
      def parse_empty_rule_body: () -> Array[AST::query_literal]
      def parse_query: (*Symbol end_tokens, ?newline_delimiter: bool) -> Array[AST::query_literal]
      def consume_query_separators: (bool newline_delimiter) -> bool
      def parse_literal: () -> AST::query_literal
      def parse_some_decl: () -> AST::SomeDecl
      def parse_some_variables: () -> Array[AST::Variable]
      def parse_some_collection: () -> AST::expression?
      def parse_with_modifier: () -> AST::WithModifier
      def parse_with_modifiers: () -> Array[AST::WithModifier]
      def parse_else_clause: () -> Hash[Symbol, untyped]
      def parse_expression: (?Integer precedence) -> AST::expression
      def parse_infix_expression: (AST::expression left, Integer precedence) -> AST::expression
      def infix_operator?: (Integer precedence) -> bool
      def parse_primary: () -> AST::expression
      def parse_infix: (AST::expression left, Token operator_token) -> AST::BinaryOp
      def parse_reference: (AST::expression base) -> AST::Reference
      def parse_array: () -> AST::expression
      def parse_object: (Token start_token, AST::expression first_key, AST::expression first_value) -> AST::ObjectLiteral
      def build_object_pairs: (AST::expression first_key, AST::expression first_value) -> Array[[AST::expression, AST::expression]]
      def parse_set: (Token start_token, ?AST::expression first_element) -> AST::SetLiteral
      def parse_array_comprehension: (Token start_token, AST::expression term) -> AST::ArrayComprehension
      def parse_object_comprehension: (Token start_token, AST::expression key, AST::expression value) -> AST::ObjectComprehension
      def parse_set_comprehension: (Token start_token, AST::expression term) -> AST::SetComprehension
      def parse_call_args: () -> Array[AST::expression]
      def parse_string_literal: () -> AST::StringLiteral
      def parse_number_literal: () -> AST::NumberLiteral
      def parse_boolean_literal: () -> AST::BooleanLiteral
      def parse_null_literal: () -> AST::NullLiteral
      def parse_unary_expression: () -> AST::UnaryOp
      def parse_parenthesized_expression: () -> AST::expression
      def parse_parenthesized_body: () -> AST::expression
      def parse_path: (Parser::IdentifierContext identifier_context) -> Array[String]
      def parse_path_segment: (Parser::IdentifierContext identifier_context) -> String
      def parse_identifier: (Parser::IdentifierContext identifier_context) -> String
      def parse_braced_literal: () -> AST::expression
      def parse_object_literal_or_comprehension: (Token start_token, AST::expression key) -> AST::expression
      def parse_identifier_expression: () -> AST::expression
      def parse_variable: () -> AST::Variable
      def parse_expression_list_until: (Symbol end_token) -> Array[AST::expression]
      def parse_expression_list_until_with_first: (Symbol end_token, AST::expression first_element) -> Array[AST::expression]
      def append_expression_list: (Array[AST::expression] elements, Symbol end_token) -> void
      def parse_object_pair: (AST::expression key) -> [AST::expression, AST::expression]
      def append_object_pairs: (Array[[AST::expression, AST::expression]] pairs) -> void
      def empty_set?: (AST::expression?) -> bool
      def empty_set_literal: (Token start_token) -> AST::SetLiteral
      def parse_reference_path: (Array[AST::RefArg] path) -> void
      def parse_dot_reference: (Array[AST::RefArg] path) -> void
      def parse_bracket_reference: (Array[AST::RefArg] path) -> void
      def safe_token_at: (Integer index) -> Token
      def record_error: (ParserError error) -> void

      private

      def errors: () -> Array[ParserError]
    end

    class Parser::IdentifierContext
      attr_reader name: String
      attr_reader allowed_types: Array[Symbol]

      def initialize: (name: String, allowed_types: Array[Symbol]) -> void
    end

    class Parser
      module Precedence
        LOWEST: Integer
        ASSIGNMENT: Integer
        OR: Integer
        AND: Integer
        EQUALS: Integer
        COMPARE: Integer
        SUM: Integer
        PRODUCT: Integer
        UNARY: Integer
        BINARY: Hash[Symbol, Integer]
      end
    end

    class Parser
      module Helpers
        def self.precedence_of: (Symbol operator) -> Integer
        def self.normalize_reference_base: (AST::expression base) -> [AST::expression, Array[AST::RefArg]]
        def self.variable_name_for: (Token token) -> String
      end
    end

    module AST
      class Base
        attr_reader location: Location?

        def initialize: (?location: Location?) -> void
        def accept: (untyped visitor) -> untyped
        def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]
        def to_s: () -> String
        def ==: (untyped other) -> bool
        def eql?: (untyped other) -> bool
        def hash: () -> Integer
        def self.format_value: (untyped value) -> String

        private

        def deconstruct_attributes: () -> Hash[Symbol, untyped]
        def deconstructable_keys: () -> Array[Symbol]
      end

      type expression = Literal | Variable | Reference | BinaryOp | UnaryOp | ArrayLiteral | ObjectLiteral | SetLiteral | ArrayComprehension | ObjectComprehension | SetComprehension | Call
      type call_name = String | Variable | Reference
      type query_literal = QueryLiteral | SomeDecl
      type query = Array[query_literal]
      type object_term = [expression, expression]

      class Literal < Base
        attr_reader value: untyped

        def initialize: (value: untyped, ?location: Location?) -> void
      end

      class StringLiteral < Literal
        attr_reader value: String

        def initialize: (value: String, ?location: Location?) -> void
      end

      class NumberLiteral < Literal
        attr_reader value: Numeric

        def initialize: (value: Numeric, ?location: Location?) -> void
      end

      class BooleanLiteral < Literal
        attr_reader value: bool

        def initialize: (value: bool, ?location: Location?) -> void
      end

      class NullLiteral < Literal
        attr_reader value: nil

        def initialize: (?location: Location?) -> void
      end

      class Variable < Base
        attr_reader name: String

        def initialize: (name: String, ?location: Location?) -> void
      end

      class Reference < Base
        attr_reader base: expression
        attr_reader path: Array[RefArg]

        def initialize: (base: expression, path: Array[RefArg], ?location: Location?) -> void
      end

      class RefArg < Base
        attr_reader value: untyped

        def initialize: (value: untyped, ?location: Location?) -> void
      end

      class DotRefArg < RefArg
        def initialize: (value: untyped, ?location: Location?) -> void
      end

      class BracketRefArg < RefArg
        def initialize: (value: untyped, ?location: Location?) -> void
      end

      class BinaryOp < Base
        OPERATORS: Array[Symbol]

        attr_reader operator: Symbol
        attr_reader left: expression
        attr_reader right: expression

        def initialize: (operator: Symbol, left: expression, right: expression, ?location: Location?) -> void

        private

        def validate_operator: () -> bool
        def validate_operator!: () -> void
      end

      class UnaryOp < Base
        OPERATORS: Array[Symbol]

        attr_reader operator: Symbol
        attr_reader operand: expression

        def initialize: (operator: Symbol, operand: expression, ?location: Location?) -> void

        private

        def validate_operator: () -> bool
        def validate_operator!: () -> void
      end

      class ArrayLiteral < Base
        attr_reader elements: Array[expression]

        def initialize: (elements: Array[expression], ?location: Location?) -> void
      end

      class ObjectLiteral < Base
        attr_reader pairs: Array[[expression, expression]]

        def initialize: (pairs: Array[[expression, expression]], ?location: Location?) -> void
      end

      class SetLiteral < Base
        attr_reader elements: Array[expression]

        def initialize: (elements: Array[expression], ?location: Location?) -> void
      end

      class ArrayComprehension < Base
        attr_reader term: expression
        attr_reader body: query

        def initialize: (term: expression, body: query, ?location: Location?) -> void
      end

      class ObjectComprehension < Base
        attr_reader term: object_term
        attr_reader body: query

        def initialize: (term: object_term, body: query, ?location: Location?) -> void
      end

      class SetComprehension < Base
        attr_reader term: expression
        attr_reader body: query

        def initialize: (term: expression, body: query, ?location: Location?) -> void
      end

      class QueryLiteral < Base
        attr_reader expression: expression
        attr_reader with_modifiers: Array[WithModifier]

        def initialize: (expression: expression, ?with_modifiers: Array[WithModifier], ?location: Location?) -> void
      end

      class SomeDecl < Base
        attr_reader variables: Array[Variable]
        attr_reader collection: expression?

        def initialize: (variables: Array[Variable], ?collection: expression?, ?location: Location?) -> void
      end

      class WithModifier < Base
        attr_reader target: expression
        attr_reader value: expression

        def initialize: (target: expression, value: expression, ?location: Location?) -> void
      end

      class Call < Base
        attr_reader name: call_name
        attr_reader args: Array[expression]

        def initialize: (name: call_name, args: Array[expression], ?location: Location?) -> void
      end

      class Module < Base
        attr_reader package: Package
        attr_reader imports: Array[Import]
        attr_reader rules: Array[Rule]

        def initialize: (package: Package, imports: Array[Import], rules: Array[Rule], ?location: Location?) -> void
      end

      class Package < Base
        attr_reader path: Array[String]

        def initialize: (path: Array[String], ?location: Location?) -> void
      end

      class Import < Base
        attr_reader path: untyped
        attr_reader alias: String?

        def initialize: (path: untyped, ?alias_name: String?, ?location: Location?) -> void
        def alias_name: () -> String?
      end

      class Rule < Base
        RULE_TYPE_LOOKUP: Array[Symbol]
        Definition: untyped

        attr_reader name: String
        attr_reader head: untyped
        attr_reader body: untyped
        attr_reader default_value: untyped
        attr_reader else_clause: untyped

        def initialize: (name: String, ?head: untyped, ?body: untyped, ?default_value: untyped, ?else_clause: untyped, ?location: Location?) -> void
        def complete?: () -> bool
        def partial_set?: () -> bool
        def partial_object?: () -> bool
        def function?: () -> bool

        private

        def rule_type: () -> Symbol?
        def resolve_rule_type: () -> (String | Symbol | nil)
        def type_from_object: () -> untyped
        def type_from_hash: () -> untyped
        attr_reader definition: untyped
      end
    end
  end
end
