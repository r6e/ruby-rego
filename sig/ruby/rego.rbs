module Ruby
  module Rego
    VERSION: String

    type position = {
      line: Integer,
      column: Integer,
      offset: Integer?,
      length: Integer?
    }

    module ErrorFormatting
      def self.format_details: (Hash[Symbol, untyped]) -> String
    end

    class Location
      attr_reader line: Integer
      attr_reader column: Integer
      attr_reader offset: Integer?
      attr_reader length: Integer?

      def self.from: (Location | position) -> Location
      def initialize: (line: Integer, column: Integer, ?offset: Integer?, ?length: Integer?) -> void
      def to_s: () -> String
    end

    class Error < StandardError
      attr_reader location: Location?

      def initialize: (?String message, location: Location?) -> void

      private

      def compose_message: (String? message) -> String
    end

    class LexerError < Error
      attr_reader line: Integer
      attr_reader column: Integer

      def initialize: (String message, line: Integer, column: Integer, offset: Integer?, length: Integer?) -> void
    end

    class ParserError < Error
      attr_reader line: Integer
      attr_reader column: Integer
      attr_reader context: String?

      def initialize: (String message, location: Location, context: String?) -> void
      def self.from_position: (String message, position: position | Location, context: String?) -> ParserError
    end

    class EvaluationError < Error
      attr_reader rule: untyped

      def initialize: (String message, rule: untyped, location: Location?) -> void
    end

    class TypeError < Error
      attr_reader expected: untyped
      attr_reader actual: untyped
      attr_reader context: String?

      def initialize: (String message, expected: untyped, actual: untyped, context: String?, location: Location?) -> void
    end

    class UnificationError < Error
      attr_reader pattern: untyped
      attr_reader value: untyped

      def initialize: (String message, pattern: untyped, value: untyped, location: Location?) -> void
    end

    module TokenType
      PACKAGE: Symbol
      IMPORT: Symbol
      AS: Symbol
      DEFAULT: Symbol
      IF: Symbol
      CONTAINS: Symbol
      SOME: Symbol
      IN: Symbol
      EVERY: Symbol
      NOT: Symbol
      WITH: Symbol
      ELSE: Symbol
      TRUE: Symbol
      FALSE: Symbol
      NULL: Symbol
      DATA: Symbol
      INPUT: Symbol

      ASSIGN: Symbol
      EQ: Symbol
      NEQ: Symbol
      LT: Symbol
      LTE: Symbol
      GT: Symbol
      GTE: Symbol
      PLUS: Symbol
      MINUS: Symbol
      STAR: Symbol
      SLASH: Symbol
      PERCENT: Symbol
      PIPE: Symbol
      AMPERSAND: Symbol
      UNIFY: Symbol

      LPAREN: Symbol
      RPAREN: Symbol
      LBRACKET: Symbol
      RBRACKET: Symbol
      LBRACE: Symbol
      RBRACE: Symbol
      DOT: Symbol
      COMMA: Symbol
      SEMICOLON: Symbol
      COLON: Symbol
      UNDERSCORE: Symbol

      STRING: Symbol
      NUMBER: Symbol
      RAW_STRING: Symbol
      IDENT: Symbol

      EOF: Symbol
      NEWLINE: Symbol
      COMMENT: Symbol

      KEYWORDS: Array[Symbol]
      OPERATORS: Array[Symbol]
      DELIMITERS: Array[Symbol]
      LITERALS: Array[Symbol]
      SPECIALS: Array[Symbol]

      def self.keyword?: (Symbol type) -> bool
      def self.operator?: (Symbol type) -> bool
      def self.literal?: (Symbol type) -> bool
    end

    class Token
      attr_reader type: Symbol
      attr_reader value: untyped
      attr_reader location: Location?

      def initialize: (type: Symbol, ?value: untyped, ?location: Location?) -> void
      def keyword?: () -> bool
      def operator?: () -> bool
      def literal?: () -> bool
      def to_s: () -> String
    end

    class Lexer
      KEYWORDS: Hash[String, Symbol]
      SINGLE_CHAR_TOKENS: Hash[String, Symbol]
      NEWLINE_CHARS: Array[String]
      WHITESPACE_CHARS: Array[String]
      EXPONENT_CHARS: Array[String]
      SIGN_CHARS: Array[String]
      IDENTIFIER_START: Regexp
      IDENTIFIER_PART: Regexp
      DIGIT: Regexp
      HEX_DIGIT: Regexp

      def initialize: (String source) -> void
      def tokenize: () -> Array[Token]

      private

      def next_token: () -> Token
      def eof_token: () -> Token
      def simple_token_for: (String char) -> Token?
      def read_colon_or_assign: () -> Token
      def read_equal_or_unify: () -> Token
      def read_not_equal: () -> Token
      def read_lt_or_lte: () -> Token
      def read_gt_or_gte: () -> Token
      def skip_whitespace: () -> void
      def skip_comment: () -> void
      def read_number: () -> Token
      def read_string: () -> Token
      def read_raw_string: () -> Token
      def read_newline: () -> Token
      def read_identifier: () -> Token
      def read_digits: () -> String
      def read_escape_sequence: (position backslash_position) -> String
      def read_unicode_escape: () -> String
      def parse_number: (String buffer, position start) -> Numeric
      def advance: () -> String
      def advance_line_break: () -> String
      def advance_newline: () -> String
      def increment_line: (Integer count) -> void
      def increment_position: (Integer count) -> void
      def peek: (?Integer distance) -> String?
      def match?: (String expected) -> bool
      def current_char: () -> String?
      def eof?: () -> bool
      def capture_position: () -> position
      def build_token: (Symbol type, untyped value, position start) -> Token
      def identifier_start?: (String? char) -> bool
      def identifier_part?: (String? char) -> bool
      def digit?: (String? char) -> bool
      def hex_digit?: (String? char) -> bool
      def whitespace?: (String? char) -> bool
      def newline?: (String? char) -> bool
      def exponent_start?: () -> bool
      def span_length_from: (position start) -> Integer
      def raise_unterminated_string: (position start) -> bot
      def raise_unterminated_raw_string: (position start) -> bot
      def raise_unexpected_eof: () -> bot
      def raise_error: (String message, position position, length: Integer?) -> bot

      private

      attr_reader source: String
      attr_reader position: Integer
      attr_reader line: Integer
      attr_reader column: Integer
      attr_reader offset: Integer
    end

    class Parser
      IDENTIFIER_TOKEN_TYPES: Array[Symbol]
      IDENTIFIER_TOKEN_NAMES: Hash[Symbol, String]
      PACKAGE_PATH_TOKEN_TYPES: Array[Symbol]
      IMPORT_PATH_TOKEN_TYPES: Array[Symbol]
      BINARY_OPERATOR_MAP: Hash[Symbol, Symbol]
      UNARY_OPERATOR_MAP: Hash[Symbol, Symbol]
      PRIMARY_PARSERS: Hash[Symbol, Symbol]

      @tokens: Array[Token]
      @current: Integer
      @errors: Array[ParserError]

      def initialize: (Array[Token] tokens) -> void
      def parse: () -> AST::Module

      private

      def tokens: () -> Array[Token]
      def current_token: () -> Token
      def peek: (?Integer distance) -> Token
      def advance: () -> Token
      def consume: (Symbol type, ?String message) -> Token
      def match?: (*Symbol types) -> bool
      def pipe_token?: () -> bool
      def rbrace_token?: () -> bool
      def newline_token?: () -> bool
      def consume_newlines: () -> void
      def at_end?: () -> bool
      def parse_error: (String message) -> bot
      def synchronize: () -> void
      def parse_module: () -> AST::Module
      def parse_statement: (Array[AST::Import] imports, Array[AST::Rule] rules) -> void
      def parse_package: () -> AST::Package
      def parse_import: () -> AST::Import
      def parse_import_alias: () -> String?
      def parse_rule: () -> AST::Rule
      def consume_default_keyword: () -> Token?
      def parse_rule_name: () -> String
      def mark_default_head: (Hash[Symbol, untyped] head) -> Hash[Symbol, untyped]
      def parse_default_value: (Token? default_token, Hash[Symbol, untyped] head) -> AST::expression?
      def parse_non_default_body: (Token? default_token) -> Array[AST::query_literal]?
      def parse_rule_definition: (Token? default_token, Hash[Symbol, untyped] head) -> Hash[Symbol, untyped]
      def validate_rule_definition: (Token? default_token, Hash[Symbol, untyped] head, Hash[Symbol, untyped] definition) -> void
      def parse_else_clause_if_present: () -> Hash[Symbol, untyped]?
      def build_rule_node: (name: String, head: Hash[Symbol, untyped], name_token: Token, definition: Hash[Symbol, untyped]) -> AST::Rule
      def parse_rule_head: (String name, Token name_token) -> Hash[Symbol, untyped]
      def parse_contains_rule_head: (String name, Token name_token) -> Hash[Symbol, untyped]
      def parse_function_rule_head: (String name, Token name_token) -> Hash[Symbol, untyped]
      def parse_bracket_rule_head: (String name, Token name_token) -> Hash[Symbol, untyped]
      def parse_partial_object_rule_head: (String name, Token name_token, AST::expression key) -> Hash[Symbol, untyped]
      def build_rule_head: (Symbol type, String name, Token name_token, **untyped attrs) -> Hash[Symbol, untyped]
      def parse_rule_head_args: () -> Array[AST::expression]
      def parse_rule_head_key: () -> AST::expression
      def parse_rule_value: () -> AST::expression?
      def parse_rule_body: () -> Array[AST::query_literal]
      def parse_braced_rule_body: () -> Array[AST::query_literal]
      def parse_empty_rule_body: () -> Array[AST::query_literal]
      def parse_query: (*Symbol end_tokens, ?newline_delimiter: bool) -> Array[AST::query_literal]
      def consume_query_separators: (bool newline_delimiter) -> bool
      def parse_literal: () -> AST::query_literal
      def parse_some_decl: () -> AST::SomeDecl
      def parse_some_variables: () -> Array[AST::Variable]
      def parse_some_collection: () -> AST::expression?
      def parse_with_modifier: () -> AST::WithModifier
      def parse_with_modifiers: () -> Array[AST::WithModifier]
      def parse_else_clause: () -> Hash[Symbol, untyped]
      def parse_expression: (?Integer precedence) -> AST::expression
      def parse_infix_expression: (AST::expression left, Integer precedence) -> AST::expression
      def infix_operator?: (Integer precedence) -> bool
      def parse_primary: () -> AST::expression
      def parse_infix: (AST::expression left, Token operator_token) -> AST::BinaryOp
      def parse_reference: (AST::expression base) -> AST::Reference
      def parse_array: () -> AST::expression
      def parse_object: (Token start_token, AST::expression first_key, AST::expression first_value) -> AST::ObjectLiteral
      def build_object_pairs: (AST::expression first_key, AST::expression first_value) -> Array[[AST::expression, AST::expression]]
      def parse_set: (Token start_token, ?AST::expression first_element) -> AST::SetLiteral
      def parse_array_comprehension: (Token start_token, AST::expression term) -> AST::ArrayComprehension
      def parse_object_comprehension: (Token start_token, AST::expression key, AST::expression value) -> AST::ObjectComprehension
      def parse_set_comprehension: (Token start_token, AST::expression term) -> AST::SetComprehension
      def parse_call_args: () -> Array[AST::expression]
      def parse_string_literal: () -> AST::StringLiteral
      def parse_number_literal: () -> AST::NumberLiteral
      def parse_boolean_literal: () -> AST::BooleanLiteral
      def parse_null_literal: () -> AST::NullLiteral
      def parse_unary_expression: () -> AST::UnaryOp
      def parse_parenthesized_expression: () -> AST::expression
      def parse_parenthesized_body: () -> AST::expression
      def parse_path: (Parser::IdentifierContext identifier_context) -> Array[String]
      def parse_path_segment: (Parser::IdentifierContext identifier_context) -> String
      def parse_identifier: (Parser::IdentifierContext identifier_context) -> String
      def parse_braced_literal: () -> AST::expression
      def parse_object_literal_or_comprehension: (Token start_token, AST::expression key) -> AST::expression
      def parse_identifier_expression: () -> AST::expression
      def parse_variable: () -> AST::Variable
      def parse_expression_list_until: (Symbol end_token) -> Array[AST::expression]
      def parse_expression_list_until_with_first: (Symbol end_token, AST::expression first_element) -> Array[AST::expression]
      def append_expression_list: (Array[AST::expression] elements, Symbol end_token) -> void
      def parse_object_pair: (AST::expression key) -> [AST::expression, AST::expression]
      def append_object_pairs: (Array[[AST::expression, AST::expression]] pairs) -> void
      def empty_set?: (AST::expression?) -> bool
      def empty_set_literal: (Token start_token) -> AST::SetLiteral
      def parse_reference_path: (Array[AST::RefArg] path) -> void
      def parse_dot_reference: (Array[AST::RefArg] path) -> void
      def parse_bracket_reference: (Array[AST::RefArg] path) -> void
      def safe_token_at: (Integer index) -> Token
      def record_error: (ParserError error) -> void

      private

      def errors: () -> Array[ParserError]
    end

    class Parser::IdentifierContext
      attr_reader name: String
      attr_reader allowed_types: Array[Symbol]

      def initialize: (name: String, allowed_types: Array[Symbol]) -> void
    end

    class Parser
      module Precedence
        LOWEST: Integer
        ASSIGNMENT: Integer
        OR: Integer
        AND: Integer
        EQUALS: Integer
        COMPARE: Integer
        SUM: Integer
        PRODUCT: Integer
        UNARY: Integer
        BINARY: Hash[Symbol, Integer]
      end
    end

    class Parser
      module Helpers
        def self.precedence_of: (Symbol operator) -> Integer
        def self.normalize_reference_base: (AST::expression base) -> [AST::expression, Array[AST::RefArg]]
        def self.variable_name_for: (Token token) -> String
      end
    end

    module AST
      class Base
        attr_reader location: Location?

        def initialize: (?location: Location?) -> void
        def accept: (untyped visitor) -> untyped
        def to_s: () -> String
        def ==: (untyped other) -> bool
        def eql?: (untyped other) -> bool
        def hash: () -> Integer
        def self.format_value: (untyped value) -> String
      end

      type expression = Literal | Variable | Reference | BinaryOp | UnaryOp | ArrayLiteral | ObjectLiteral | SetLiteral | ArrayComprehension | ObjectComprehension | SetComprehension | Call
      type call_name = String | Variable | Reference
      type query_literal = QueryLiteral | SomeDecl
      type query = Array[query_literal]
      type object_term = [expression, expression]

      class Literal < Base
        attr_reader value: untyped

        def initialize: (value: untyped, ?location: Location?) -> void
      end

      class StringLiteral < Literal
        attr_reader value: String

        def initialize: (value: String, ?location: Location?) -> void
      end

      class NumberLiteral < Literal
        attr_reader value: Numeric

        def initialize: (value: Numeric, ?location: Location?) -> void
      end

      class BooleanLiteral < Literal
        attr_reader value: bool

        def initialize: (value: bool, ?location: Location?) -> void
      end

      class NullLiteral < Literal
        attr_reader value: nil

        def initialize: (?location: Location?) -> void
      end

      class Variable < Base
        attr_reader name: String

        def initialize: (name: String, ?location: Location?) -> void
      end

      class Reference < Base
        attr_reader base: expression
        attr_reader path: Array[RefArg]

        def initialize: (base: expression, path: Array[RefArg], ?location: Location?) -> void
      end

      class RefArg < Base
        attr_reader value: untyped

        def initialize: (value: untyped, ?location: Location?) -> void
      end

      class DotRefArg < RefArg
        def initialize: (value: untyped, ?location: Location?) -> void
      end

      class BracketRefArg < RefArg
        def initialize: (value: untyped, ?location: Location?) -> void
      end

      class BinaryOp < Base
        OPERATORS: Array[Symbol]

        attr_reader operator: Symbol
        attr_reader left: expression
        attr_reader right: expression

        def initialize: (operator: Symbol, left: expression, right: expression, ?location: Location?) -> void

        private

        def validate_operator: () -> bool
        def validate_operator!: () -> void
      end

      class UnaryOp < Base
        OPERATORS: Array[Symbol]

        attr_reader operator: Symbol
        attr_reader operand: expression

        def initialize: (operator: Symbol, operand: expression, ?location: Location?) -> void

        private

        def validate_operator: () -> bool
        def validate_operator!: () -> void
      end

      class ArrayLiteral < Base
        attr_reader elements: Array[expression]

        def initialize: (elements: Array[expression], ?location: Location?) -> void
      end

      class ObjectLiteral < Base
        attr_reader pairs: Array[[expression, expression]]

        def initialize: (pairs: Array[[expression, expression]], ?location: Location?) -> void
      end

      class SetLiteral < Base
        attr_reader elements: Array[expression]

        def initialize: (elements: Array[expression], ?location: Location?) -> void
      end

      class ArrayComprehension < Base
        attr_reader term: expression
        attr_reader body: query

        def initialize: (term: expression, body: query, ?location: Location?) -> void
      end

      class ObjectComprehension < Base
        attr_reader term: object_term
        attr_reader body: query

        def initialize: (term: object_term, body: query, ?location: Location?) -> void
      end

      class SetComprehension < Base
        attr_reader term: expression
        attr_reader body: query

        def initialize: (term: expression, body: query, ?location: Location?) -> void
      end

      class QueryLiteral < Base
        attr_reader expression: expression
        attr_reader with_modifiers: Array[WithModifier]

        def initialize: (expression: expression, ?with_modifiers: Array[WithModifier], ?location: Location?) -> void
      end

      class SomeDecl < Base
        attr_reader variables: Array[Variable]
        attr_reader collection: expression?

        def initialize: (variables: Array[Variable], ?collection: expression?, ?location: Location?) -> void
      end

      class WithModifier < Base
        attr_reader target: expression
        attr_reader value: expression

        def initialize: (target: expression, value: expression, ?location: Location?) -> void
      end

      class Call < Base
        attr_reader name: call_name
        attr_reader args: Array[expression]

        def initialize: (name: call_name, args: Array[expression], ?location: Location?) -> void
      end

      class Module < Base
        attr_reader package: Package
        attr_reader imports: Array[Import]
        attr_reader rules: Array[Rule]

        def initialize: (package: Package, imports: Array[Import], rules: Array[Rule], ?location: Location?) -> void
      end

      class Package < Base
        attr_reader path: Array[String]

        def initialize: (path: Array[String], ?location: Location?) -> void
      end

      class Import < Base
        attr_reader path: untyped
        attr_reader alias: String?

        def initialize: (path: untyped, ?alias_name: String?, ?location: Location?) -> void
        def alias_name: () -> String?
      end

      class Rule < Base
        RULE_TYPE_LOOKUP: Array[Symbol]
        Definition: untyped

        attr_reader name: String
        attr_reader head: untyped
        attr_reader body: untyped
        attr_reader default_value: untyped
        attr_reader else_clause: untyped

        def initialize: (name: String, ?head: untyped, ?body: untyped, ?default_value: untyped, ?else_clause: untyped, ?location: Location?) -> void
        def complete?: () -> bool
        def partial_set?: () -> bool
        def partial_object?: () -> bool
        def function?: () -> bool

        private

        def rule_type: () -> Symbol?
        def resolve_rule_type: () -> (String | Symbol | nil)
        def type_from_object: () -> untyped
        def type_from_hash: () -> untyped
        attr_reader definition: untyped
      end
    end
  end
end
