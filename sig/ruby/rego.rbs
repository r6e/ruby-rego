module Ruby
  module Rego
    VERSION: String

    def self.parse: (String source) -> AST::Module
    def self.compile: (String source) -> CompiledModule
    def self.evaluate: (String source, ?input: untyped, ?data: untyped, ?query: untyped) -> Result

    type position = {
      line: Integer,
      column: Integer,
      offset: Integer?,
      length: Integer?
    }

    module ErrorFormatting
      def self.format_details: (Hash[Symbol, untyped]) -> String
    end

    module ErrorHandling
      def self.wrap: (String context) { () -> untyped } -> untyped
      def self.location_from: (untyped error) -> Location?

      private

      def self.build_error: (String context, StandardError error) -> Error
    end

    module ErrorPayload
      def self.from: (untyped error) -> untyped

      private

      def self.standard_error_payload: (untyped error) -> Hash[Symbol, untyped]
    end

    class Location
      attr_reader line: Integer
      attr_reader column: Integer
      attr_reader offset: Integer?
      attr_reader length: Integer?

      def self.from: (Location | position) -> Location
      def initialize: (line: Integer, column: Integer, ?offset: Integer?, ?length: Integer?) -> void
      def to_s: () -> String
    end

    class Error < StandardError
      attr_reader location: Location?

      def initialize: (?String message, location: Location?) -> void
      def to_h: () -> Hash[Symbol, untyped]

      private

      attr_reader raw_message: String?
      def compose_message: (String? message) -> String
    end

    class LexerError < Error
      attr_reader line: Integer
      attr_reader column: Integer

      def initialize: (String message, line: Integer, column: Integer, offset: Integer?, length: Integer?) -> void
    end

    class ParserError < Error
      attr_reader line: Integer
      attr_reader column: Integer
      attr_reader context: String?

      def initialize: (String message, location: Location, context: String?) -> void
      def self.from_position: (String message, position: position | Location, context: String?) -> ParserError
    end

    class CompilationError < Error
    end

    class EvaluationError < Error
      attr_reader rule: untyped

      def initialize: (String message, rule: untyped, ?location: Location?) -> void
    end

    class TypeError < Error
      attr_reader expected: untyped
      attr_reader actual: untyped
      attr_reader context: String?

      def initialize: (String message, expected: untyped, actual: untyped, context: String?, location: Location?) -> void
    end

    class BuiltinArgumentError < TypeError
    end

    class ObjectKeyConflictError < Error
    end

    class UnificationError < Error
      attr_reader pattern: untyped
      attr_reader value: untyped

      def initialize: (String message, pattern: untyped, value: untyped, location: Location?) -> void
    end

    class Value
      TYPE_NAME: String

      def self.from_ruby: (untyped) -> Value
      def initialize: (?untyped value) -> void
      attr_reader value: untyped
      def truthy?: () -> bool
      def to_ruby: () -> untyped
      def type_name: () -> String
      def undefined?: () -> bool
      def object_key: () -> untyped
      def fetch_reference: (untyped key) -> Value
      def ==: (untyped) -> bool
      def eql?: (untyped) -> bool
      def hash: () -> Integer

      private

      def self.build_value: (untyped) -> Value?
      def self.build_simple_value: (untyped) -> Value?
      def self.build_composite_value: (untyped) -> Value?
    end

    class StringValue < Value
      TYPE_NAME: String

      def initialize: (String value) -> void
    end

    class NumberValue < Value
      TYPE_NAME: String

      def initialize: (Numeric value) -> void
    end

    class BooleanValue < Value
      TYPE_NAME: String

      def initialize: (bool value) -> void
      def truthy?: () -> bool
    end

    class NullValue < Value
      TYPE_NAME: String

      def initialize: () -> void
      def truthy?: () -> bool
    end

    class UndefinedValue < Value
      TYPE_NAME: String
      UNDEFINED: untyped

      def initialize: () -> void
      def truthy?: () -> bool
      def to_ruby: () -> untyped
      def object_key: () -> UndefinedValue
    end

    class ArrayValue < Value
      TYPE_NAME: String

      def initialize: (Array[untyped] elements) -> void
      def fetch_index: (Integer index) -> Value
      def fetch_reference: (untyped key) -> Value
      def to_ruby: () -> Array[untyped]
    end

    class ObjectValue < Value
      TYPE_NAME: String

      def initialize: (Hash[untyped, untyped] pairs) -> void
      def fetch: (untyped key) -> Value
      def fetch_reference: (untyped key) -> Value
      def to_ruby: () -> Hash[untyped, untyped]

      private

      def fetch_by_symbol_key: (Symbol key) -> Value
      def normalize_pairs: (Hash[untyped, untyped] pairs) -> Hash[untyped, Value]
      def ensure_unique_key: (untyped normalized_key, Hash[untyped, untyped] key_sources, untyped key) -> void
    end

    class SetValue < Value
      TYPE_NAME: String

      def initialize: (Set[untyped] | Array[untyped] elements) -> void
      def include?: (untyped value) -> bool
      def to_ruby: () -> Set[untyped]
    end

    module Builtins
      module BuiltinInvocation
        private

        def invoke_entry: (untyped entry, Array[untyped] args) -> Value
        def ensure_array_args: (untyped args, String builtin_name) -> Array[untyped]
        def normalize_name: (String | Symbol name) -> String
      end

      module Base
        def self.assert_arity: (Array[untyped] args, Integer | Array[Integer] expected, ?name: String?) -> void
        def self.assert_type: (untyped value, expected: Class | Array[Class], ?context: String?) -> void
        def self.to_ruby: (untyped value) -> untyped
        def self.to_value: (untyped value) -> Value

        private

        def self.normalize_expected: (Class | Array[Class]) -> Array[Class]
        def self.normalize_arity: (Integer | Array[Integer] expected) -> Array[Integer]
        def self.format_arity: (Array[Integer] expected_list) -> String
        def self.arity_valid?: (Integer actual, Integer | Array[Integer] expected) -> bool
        def self.raise_builtin_arity_error: (Integer actual, Integer | Array[Integer] expected, String? name) -> void
        def self.raise_type_error: (expected: String, actual: String, ?context: String?) -> void
      end

      class BuiltinRegistry
        @builtins: Hash[String, untyped]
        Entry: untyped

        def initialize: () -> void
        def self.instance: () -> BuiltinRegistry
        def register: (String | Symbol name, Integer | Array[Integer] arity) { (*untyped) -> untyped } -> void
        def call: (String | Symbol name, Array[untyped] args) -> Value
        def entry_for: (String | Symbol name) -> untyped
        def with_entry_override: (String | Symbol name, untyped entry) { () -> untyped } -> untyped
        def with_override: (String | Symbol name, untyped entry) -> BuiltinRegistryOverlay
        def registered?: (String | Symbol name) -> bool

        private

        def normalize_name: (String | Symbol name) -> String
        def validate_arity: (Integer | Array[Integer] arity) -> void
        def integer_arity_valid?: (untyped arity) -> bool
        def array_arity_valid?: (untyped arity) -> bool
        def fetch_entry: (String builtin_name) -> untyped
        def invoke_entry: (untyped entry, Array[untyped] args) -> Value
        def ensure_array_args: (untyped args, String builtin_name) -> Array[untyped]
      end

      class BuiltinRegistryOverlay
        @base_registry: BuiltinRegistry
        @overrides: Hash[String, untyped]

        def initialize: (base_registry: BuiltinRegistry, ?overrides: Hash[String, untyped]) -> void
        def with_override: (String | Symbol name, untyped entry) -> BuiltinRegistryOverlay
        def call: (String | Symbol name, Array[untyped] args) -> Value
        def entry_for: (String | Symbol name) -> untyped
        def registered?: (String | Symbol name) -> bool

        private

        attr_reader base_registry: BuiltinRegistry
        attr_reader overrides: Hash[String, untyped]
        def normalize_name: (String | Symbol name) -> String
        def invoke_entry: (untyped entry, Array[untyped] args) -> Value
        def ensure_array_args: (untyped args, String builtin_name) -> Array[untyped]
      end

      module RegistryHelpers
        def register_configured_functions: (BuiltinRegistry registry, Hash[String, Hash[Symbol, untyped]] mapping) -> void

        private

        def register_configured_function: (BuiltinRegistry registry, String name, Hash[Symbol, untyped] config) -> void
      end

      module NumericHelpers
        def self.integer_value: (Value value, context: String) -> Integer
        def self.non_negative_integer: (Value value, context: String) -> Integer

        private

        def self.raise_integer_error: (Numeric numeric, String context) -> bot
      end

      module Types
        TYPE_PREDICATES: Hash[String, Symbol]

        def self.register!: () -> BuiltinRegistry
        def self.is_string: (Value value) -> BooleanValue
        def self.is_number: (Value value) -> BooleanValue
        def self.is_boolean: (Value value) -> BooleanValue
        def self.is_array: (Value value) -> BooleanValue
        def self.is_object: (Value value) -> BooleanValue
        def self.is_set: (Value value) -> BooleanValue
        def self.is_null: (Value value) -> BooleanValue

        private

        def self.register_predicate: (BuiltinRegistry registry, String name, Symbol handler) -> void
      end

      module Aggregates
        AGGREGATE_FUNCTIONS: Hash[String, Symbol]

        def self.register!: () -> BuiltinRegistry
        def self.count: (Value collection) -> NumberValue
        def self.sum: (Value array) -> NumberValue
        def self.max: (Value array) -> NumberValue
        def self.min: (Value array) -> NumberValue
        def self.all: (Value array) -> BooleanValue
        def self.any: (Value array) -> BooleanValue

        private

        def self.register_function: (BuiltinRegistry registry, String name, Symbol handler) -> void
        def self.numeric_array: (Value array, name: String) -> Array[Numeric]
        def self.ensure_non_empty: (Array[Numeric] numbers, name: String) -> void
      end

      module Strings
        extend RegistryHelpers

        BASE_DIGITS: Array[String]
        STRING_FUNCTIONS: Hash[String, Hash[Symbol, untyped]]

        def self.register!: () -> BuiltinRegistry
        def self.concat: (Value delimiter, Value array) -> StringValue
        def self.contains: (Value haystack, Value needle) -> BooleanValue
        def self.startswith: (Value string, Value prefix) -> BooleanValue
        def self.endswith: (Value string, Value suffix) -> BooleanValue
        def self.format_int: (Value number, Value base) -> StringValue
        def self.indexof: (Value haystack, Value needle) -> NumberValue
        def self.lower: (Value string) -> StringValue
        def self.upper: (Value string) -> StringValue
        def self.split: (Value string, Value delimiter) -> ArrayValue
        def self.sprintf: (Value format, Value args) -> StringValue
        def self.substring: (Value string, Value offset, Value length) -> StringValue
        def self.trim: (Value string, Value cutset) -> StringValue
        def self.trim_left: (Value string, Value cutset) -> StringValue
        def self.trim_right: (Value string, Value cutset) -> StringValue
        def self.trim_space: (Value string) -> StringValue

        private

        def self.string_value: (Value value, context: String) -> String
        def self.array_values: (Value value, name: String) -> Array[Value]
        def self.string_array: (Value value, name: String) -> Array[String]
        def self.ensure_base: (Integer base_value) -> void
        def self.trim_with_cutset: (Value string, Value cutset, Hash[Symbol, untyped] context) -> StringValue
        def self.base_encode: (Integer number_value, Integer base_value) -> String
        def self.negative_prefix: (Integer number_value) -> String
        def self.encode_digits: (Integer remaining, Integer base_value) -> String
        def self.sprintf_values: (Value args) -> Array[untyped]
        def self.raise_sprintf_error: (ArgumentError | ::TypeError error) -> bot
        def self.trim_regex: (String cutset_text, mode: Symbol) -> Regexp
        def self.trimmed_text: (Value string, Value cutset, Hash[Symbol, untyped] context) -> String
        def self.trim_context: (Hash[Symbol, untyped] context) -> [String, Symbol]
        def self.trim_inputs: (Value string, Value cutset, String name) -> [String, String]
        def self.apply_trim_or_original: (String string_text, String cutset_text, Symbol mode) -> String
        def self.apply_trim: (String string_text, String cutset_text, Symbol mode) -> String
        def self.trim_patterns: (String escaped, Symbol mode) -> Array[String]
        def self.string_pair: (Value left, Value right, left_context: String, right_context: String) -> [String, String]
      end

      module Collections
        extend RegistryHelpers

        COLLECTION_FUNCTIONS: Hash[String, Hash[Symbol, untyped]]
        MISSING_SET_ARGUMENT: Object

        def self.register!: () -> BuiltinRegistry
        def self.set: (?Value value) -> SetValue
        def self.sort: (Value array) -> ArrayValue
        def self.array_concat: (Value left, Value right) -> ArrayValue
        def self.array_slice: (Value array, Value start, Value stop) -> ArrayValue
        def self.object_get: (Value object, Value key, Value default) -> Value
        def self.object_keys: (Value object) -> ArrayValue
        def self.object_remove: (Value object, Value keys) -> ObjectValue
        def self.union: (Value left, Value right) -> Value
        def self.intersection: (Value left, Value right) -> SetValue
        def self.set_diff: (Value left, Value right) -> SetValue

        private

        def self.raise_union_type_error: (Value left, Value right) -> bot
      end

      module Collections::ArrayOps
        def self.sort: (Value array) -> ArrayValue
        def self.array_concat: (Value left, Value right) -> ArrayValue
        def self.array_slice: (Value array, Value start, Value stop) -> ArrayValue

        private

        def self.array_values: (Value value, name: String) -> Array[Value]
        def self.ensure_uniform_sort_type: (Array[Value] elements) -> void
        def self.sort_type: (Array[Value] elements) -> Class
        def self.validate_sort_element: (Value element, Class type, Integer index) -> void
        def self.raise_sort_type_error: (Class expected_type, Class actual_type) -> bot
        def self.slice_indices: (Value start, Value stop) -> [Integer, Integer]
        def self.slice_elements: (Array[Value] elements, Integer start_index, Integer stop_index) -> Array[Value]
      end

      module Collections::ObjectOps
        def self.object_get: (Value object, Value key, Value default) -> Value
        def self.object_keys: (Value object) -> ArrayValue
        def self.object_remove: (Value object, Value keys) -> ObjectValue
        def self.union_objects: (Value left, Value right) -> ObjectValue

        private

        def self.object_value: (Value value, name: String) -> ObjectValue
        def self.normalize_object_key: (untyped key) -> untyped
        def self.key_collection: (Value keys, name: String) -> Set[untyped]
        def self.key_values: (Value keys, name: String) -> Array[Value]
        def self.array_key_values: (ArrayValue keys) -> Array[Value]
        def self.values_from_set: (SetValue keys) -> Array[Value]
        def self.merge_objects: (Hash[untyped, Value] left_obj, Hash[untyped, Value] right_obj) -> Hash[untyped, Value]
        def self.conflicting_key: (Hash[untyped, Value] left_obj, Hash[untyped, Value] right_obj) -> untyped?
        def self.raise_object_conflict: (untyped key, Hash[untyped, Value] left_obj, Hash[untyped, Value] right_obj) -> bot
      end

      module Collections::SetOps
        def self.intersection: (Value left, Value right) -> SetValue
        def self.set_diff: (Value left, Value right) -> SetValue
        def self.union_sets: (Value left, Value right) -> SetValue

        private

        def self.set_operation: (Value left, Value right, name: String) { (Set[Value], Set[Value]) -> Set[Value] } -> SetValue
        def self.set_contents: (Value value, name: String) -> Set[Value]
      end

      module Comparisons
        extend RegistryHelpers

        COMPARISON_FUNCTIONS: Hash[String, Hash[Symbol, untyped]]

        def self.register!: () -> BuiltinRegistry
        def self.equal: (Value left, Value right) -> BooleanValue
        def self.to_number: (Value value) -> NumberValue
        def self.cast_string: (Value value) -> StringValue
        def self.cast_boolean: (Value value) -> BooleanValue
        def self.cast_array: (Value value) -> ArrayValue
        def self.cast_set: (Value value) -> SetValue
        def self.cast_object: (Value value) -> ObjectValue

        private
      end

      module Comparisons::Casts
        def self.to_number: (Value value) -> NumberValue
        def self.cast_string: (Value value) -> StringValue
        def self.cast_boolean: (Value value) -> BooleanValue
        def self.cast_array: (Value value) -> ArrayValue
        def self.cast_set: (Value value) -> SetValue
        def self.cast_object: (Value value) -> ObjectValue

        private

        def self.number_from_string: (String text) -> Numeric
        def self.raise_number_error: (String text) -> bot
        def self.boolean_from_string: (String text) -> BooleanValue
        def self.boolean_from_number: (Numeric number) -> BooleanValue
        def self.raise_cast_error: (String message, String context, untyped actual) -> bot
        def self.raise_type_mismatch: (String context, String expected, String actual) -> bot
      end
    end

    module EnvironmentOverrides
      UNSET: untyped

      def with_overrides: (?input: untyped, ?data: untyped) { (untyped) -> untyped } -> untyped
      def memoization: () -> Memoization::Store

      private

      def apply_overrides: (untyped input, untyped data) -> void
    end

    module EnvironmentReferenceResolution
      def resolve_reference: (untyped ref) -> Value
      def reference_key_for: (AST::Variable variable) -> untyped

      private

      def lookup: (String | Symbol name) -> Value
      def resolve_base: (untyped base) -> Value
      def resolve_path_segment: (Value current, untyped segment) -> Value
      def resolve_reference_path: (Value current, Array[untyped] path) -> Value
      def extract_reference_key: (untyped segment) -> untyped
      def resolve_reference_variable: (untyped value) -> untyped
    end

    class Environment::State
      attr_reader input: untyped
      attr_reader data: untyped
      attr_reader rules: Hash[untyped, untyped]
      attr_reader builtin_registry: Builtins::BuiltinRegistry | Builtins::BuiltinRegistryOverlay

      def initialize: (input: untyped, data: untyped, rules: Hash[untyped, untyped], builtin_registry: Builtins::BuiltinRegistry | Builtins::BuiltinRegistryOverlay) -> void
    end

    module Memoization
      class Context
        attr_reader rule_values: Hash[String, Value]
        attr_reader reference_values: Hash[AST::Reference, Value]
        attr_reader reference_keys: Hash[AST::Reference, untyped]
        attr_reader function_values: Hash[Array[untyped], Value]

        def initialize: () -> void
      end

      class Store
        def initialize: () -> void
        def reset!: () -> void
        def reset: () -> void
        def with_context: () { () -> untyped } -> untyped
        def context: () -> Context
      end
    end

    class Environment
      RESERVED_BINDINGS: Hash[String, Symbol]
      RESERVED_NAMES: Array[String]

      attr_reader input: Value
      attr_reader data: Value
      attr_reader rules: Hash[untyped, untyped]
      attr_reader builtin_registry: Builtins::BuiltinRegistry | Builtins::BuiltinRegistryOverlay
      attr_reader memoization: Memoization::Store

      def initialize: (input: untyped, data: untyped, rules: Hash[untyped, untyped], ?builtin_registry: Builtins::BuiltinRegistry | Builtins::BuiltinRegistryOverlay) -> void
      def push_scope: () -> Environment
      def pop_scope: () -> void
      def bind: (String | Symbol name, untyped value) -> Value
      def lookup: (String | Symbol name) -> Value
      def local_bound?: (String | Symbol name) -> bool
      def resolve_reference: (untyped ref) -> Value
      def reference_key_for: (AST::Variable variable) -> untyped
      def with_bindings: (Hash[String | Symbol, untyped] bindings) { () -> untyped } -> untyped
      def with_overrides: (?input: untyped, ?data: untyped) { (Environment) -> untyped } -> untyped
      def with_builtin_registry: (Builtins::BuiltinRegistry | Builtins::BuiltinRegistryOverlay registry) { (Environment) -> untyped } -> untyped
      def self.from_state: (Environment::State state) -> Environment
      def reset!: (Environment::State state) -> Environment
      def reset: (Environment::State state) -> Environment
      def prepare_for_pool: () -> Environment

      private

      attr_reader locals: Array[Hash[String, Value]]
      attr_reader scope_pool: Array[Hash[String, Value]]
      def fresh_scope: () -> Hash[String, Value]
      def reset_scopes: () -> void
      def apply_state: (Environment::State state) -> void
      def resolve_base: (untyped base) -> Value
      def resolve_path_segment: (Value current, untyped segment) -> Value
      def resolve_reference_path: (Value current, Array[untyped] path) -> Value
      def extract_reference_key: (untyped segment) -> untyped
      def resolve_reference_variable: (untyped value) -> untyped
    end

    class EnvironmentPool
      def initialize: (?max_size: Integer?) -> void
      def checkout: (Environment::State state) -> Environment
      def checkin: (Environment environment) -> void

      private

      def max_size: () -> untyped
      def max_size_full?: (Integer current_size) -> bool
      def unbounded: () -> untyped
      def normalized_max_size: (untyped value) -> untyped
    end

    module WithModifiers
      class WithModifier
        attr_reader target: untyped
        attr_reader value: untyped

        def initialize: (target: untyped, value: untyped) -> void
        def with_environment: (Environment environment, Evaluator::ExpressionEvaluator expression_evaluator) { (Environment) -> untyped } -> untyped
      end

      class WithModifierApplier
        def self.apply: (Array[AST::WithModifier] modifiers, Environment environment, Evaluator::ExpressionEvaluator expression_evaluator) { (Environment) -> untyped } -> untyped

        private

        def self.build_chain: (Array[AST::WithModifier] modifiers, Evaluator::ExpressionEvaluator expression_evaluator, untyped block) -> untyped
        def self.wrap_modifier: (AST::WithModifier modifier, Evaluator::ExpressionEvaluator expression_evaluator, untyped block) -> untyped
      end

      class WithModifierContext
        def initialize: (modifier: WithModifier, environment: Environment, expression_evaluator: Evaluator::ExpressionEvaluator) -> void
        def apply: () { (Environment) -> untyped } -> untyped

        private

        attr_reader modifier: WithModifier
        attr_reader environment: Environment
        attr_reader expression_evaluator: Evaluator::ExpressionEvaluator
        def target: () -> untyped
        def value: () -> untyped
        def apply_reference: () { (Environment) -> untyped } -> untyped
        def reference_scope: () -> WithModifierRootScope
        def reference_override: (WithModifierRootScope scope) -> untyped
        def reference_path_keys: () -> (Array[untyped] | UndefinedValue)
        def apply_variable: () { (Environment) -> untyped } -> untyped
        def apply_builtin_override: (String name) { (Environment) -> untyped } -> untyped
        def resolved_value: () -> untyped
      end

      class WithModifierPathOverride
        def initialize: (base_value: untyped, keys: Array[untyped], replacement: untyped, location: Location?) -> void
        def apply: () -> untyped

        private

        attr_reader base_value: untyped
        attr_reader keys: Array[untyped]
        attr_reader replacement: untyped
        attr_reader location: Location?
        def apply_to: (untyped container, Array[untyped] path_keys) -> untyped
        def apply_hash: (Hash[untyped, untyped] container, Array[untyped] path_keys) -> Hash[untyped, untyped]
        def apply_array: (Array[untyped] container, Array[untyped] path_keys) -> Array[untyped]
        def array_index: (untyped key) -> Integer
        def array_index_key?: (untyped key) -> bool
        def numeric_key?: (untyped key) -> bool
        def apply_missing_container: (Array[untyped] path_keys) -> untyped
        def invalid_index_error: (untyped key) -> EvaluationError
      end

      class WithModifierBuiltinOverride
        def initialize: (name: String, value: untyped, expression_evaluator: Evaluator::ExpressionEvaluator, location: Location?) -> void
        def apply: (Environment environment) { (Environment) -> untyped } -> untyped

        private

        attr_reader name: String
        attr_reader value: untyped
        attr_reader expression_evaluator: Evaluator::ExpressionEvaluator
        attr_reader location: Location?
        def override_entry: (Builtins::BuiltinRegistry | Builtins::BuiltinRegistryOverlay registry, Environment environment) -> untyped
        def replacement_entry: (Builtins::BuiltinRegistry | Builtins::BuiltinRegistryOverlay registry, Environment environment) -> untyped
        def function_entry: (Environment environment, String function_name) -> untyped
        def ensure_matching_arity: (Integer | Array[Integer] expected, Integer | Array[Integer] actual) -> void
        def normalize_arity_list: (Integer | Array[Integer] arity) -> Array[Integer]
        def replacement_name: () -> String
        def direct_name_from_value: () -> String?
        def reference_name_from_value: () -> String?
        def resolved_name_from_value: () -> String?
      end

      class WithModifierRootScope
        ROOT_NAMES: Array[String]

        def initialize: (environment: Environment, name: String, location: Location?) -> void
        def base_value: () -> untyped
        def with_override: (untyped overridden) { (Environment) -> untyped } -> untyped

        private

        attr_reader environment: Environment
        attr_reader name: String
        attr_reader location: Location?
        def input_scope?: () -> bool
        def validate_name: () -> void
      end

      class WithModifierPathKeyResolver
        def initialize: (expression_evaluator: Evaluator::ExpressionEvaluator) -> void
        def resolve: (untyped segment) -> untyped

        private

        attr_reader expression_evaluator: Evaluator::ExpressionEvaluator
        def resolved_key: (untyped raw) -> untyped
      end
    end

    class Unifier
      class ReferenceKeyContext
        attr_reader current: Value
        attr_reader env: Environment
        attr_reader bindings: Hash[String, Value]
        attr_reader variable_resolver: untyped

        def initialize: (current: Value, env: Environment, bindings: Hash[String, Value], ?variable_resolver: untyped) -> void
      end

      def initialize: (?variable_resolver: untyped) -> void
      def unify: (untyped pattern, untyped value, Environment env) -> Array[Hash[String, Value]]
      def unify_array: (Array[untyped] pattern_elems, untyped value_array, Environment env, ?Hash[String, Value] bindings) -> Array[Hash[String, Value]]
      def unify_object: (Array[[untyped, untyped]] pattern_pairs, untyped value_obj, Environment env, ?Hash[String, Value] bindings) -> Array[Hash[String, Value]]
      def reference_bindings: (AST::Reference reference, Environment env, ?Hash[String, Value] bindings, ?base_value: Value?, ?variable_resolver: untyped) -> Array[[Hash[String, Value], Value]]

      private

      def unify_with_bindings: (untyped pattern, untyped value, Environment env, Hash[String, Value] bindings) -> Array[Hash[String, Value]]
      def structured_unification: (untyped pattern, Value resolved_value, Environment env, Hash[String, Value] bindings) -> Array[Hash[String, Value]]?
      def apply_unification: (untyped pattern, Value resolved_value, Environment env, Hash[String, Value] bindings) -> Array[Hash[String, Value]]
      def reduce_array_bindings: (Array[untyped] pattern_elems, Array[Value] elements, Environment env, Hash[String, Value] bindings) -> Array[Hash[String, Value]]
      def reduce_object_pairs: (Array[[untyped, untyped]] pattern_pairs, Hash[untyped, Value] object_values, Environment env, Hash[String, Value] bindings) -> Array[Hash[String, Value]]
      def unify_object_pair: (untyped key_pattern, untyped value_pattern, Hash[untyped, Value] object_values, Environment env, Hash[String, Value] bindings) -> Array[Hash[String, Value]]
      def unify_object_candidate: (untyped candidate_key, untyped key_pattern, untyped value_pattern, Hash[untyped, Value] object_values, Environment env, Hash[String, Value] bindings) -> Array[Hash[String, Value]]
      def bind_key_variable: (untyped key_pattern, untyped candidate_key, Hash[String, Value] bindings, Environment env) -> Hash[String, Value]?
      def unify_reference: (AST::Reference pattern, Value resolved_value, Environment env, Hash[String, Value] bindings) -> Array[Hash[String, Value]]
      def resolve_reference_base: (untyped base, Environment env, Hash[String, Value] bindings) -> Value
      def traverse_reference: (Value current, Array[AST::RefArg] path, Environment env, Hash[String, Value] bindings, ?variable_resolver: untyped) -> Array[[Hash[String, Value], Value]]
      def reference_key_candidates: (Value current, untyped key_node, Environment env, Hash[String, Value] bindings, ?variable_resolver: untyped) -> Array[[untyped, Hash[String, Value]?]]
      def variable_key_candidates: (AST::Variable key_node, Array[untyped] keys, ReferenceKeyContext context) -> Array[[untyped, Hash[String, Value]?]]
      def value_key_candidates: (untyped key_node, ReferenceKeyContext context) -> Array[[untyped, Hash[String, Value]?]]
      def wildcard_key_candidates: (Array[untyped] keys, Hash[String, Value] bindings) -> Array[[untyped, Hash[String, Value]?]]
      def bound_key_candidate: (String name, ReferenceKeyContext context) -> Array[[untyped, Hash[String, Value]?]]?
      def resolved_key_candidate: (String name, ReferenceKeyContext context) -> Array[[untyped, Hash[String, Value]?]]?
      def binding_key_candidates: (String name, Array[untyped] keys, Hash[String, Value] bindings) -> Array[[untyped, Hash[String, Value]?]]
      def resolved_reference_value: (untyped resolved) -> untyped
      def resolve_variable_reference: (String name, untyped resolver) -> Value?
      def reference_keys_for: (Value current) -> Array[untyped]
      def normalize_reference_key: (Value current, untyped key) -> untyped
    end

    module Unifier::Helpers
      def self.scalar_pattern_value: (untyped pattern, Environment env) -> Value
      def self.value_for_pattern: (untyped pattern, Environment env) -> Value
      def self.normalize_value: (untyped value, Environment env) -> Value
      def self.normalize_array: (untyped value) -> Array[Value]?
      def self.normalize_elements: (Array[untyped] elements) -> Array[Value]?
      def self.object_pairs: (untyped value) -> Hash[untyped, untyped]?
      def self.normalize_key: (untyped key) -> untyped
      def self.normalize_object: (untyped value) -> Hash[untyped, Value]?
      def self.bound_value_for: (String name, Hash[String, Value] bindings, Environment env) -> Value?
      def self.merge_bindings: (Hash[String, Value] bindings, Hash[String, Value] additions) -> Hash[String, Value]?
      def self.unify_variable: (AST::Variable variable, Value value, Environment env, Hash[String, Value] bindings) -> Array[Hash[String, Value]]
      def self.variable_candidate_keys: (AST::Variable key_pattern, Array[untyped] keys, Environment env, Hash[String, Value] bindings) -> Array[untyped]
      def self.bind_key_variable: (untyped key_pattern, untyped candidate_key, Hash[String, Value] bindings, Environment env) -> Hash[String, Value]?
      def self.candidate_keys_for: (untyped key_pattern, Array[untyped] keys, Environment env, Hash[String, Value] bindings) -> Array[untyped]
      def self.match_scalar: (untyped pattern, Value resolved_value, Environment env, Hash[String, Value] bindings) -> Array[Hash[String, Value]]
    end

    class Result
      attr_reader value: Value
      attr_reader bindings: Hash[String, Value]
      attr_reader success: bool
      attr_reader errors: Array[untyped]

      def initialize: (value: untyped, success: bool, ?bindings: Hash[String | Symbol, untyped], ?errors: Array[untyped]) -> void
      def success?: () -> bool
      def undefined?: () -> bool
      def to_h: () -> Hash[Symbol, untyped]
      def to_json: (*untyped) -> String

      private

      def add_bindings: (Hash[String | Symbol, untyped] bindings) -> void
    end

    class Policy
      def initialize: (String source, ?environment_pool: EnvironmentPool) -> void
      def evaluate: (?input: untyped, ?data: untyped, ?query: untyped) -> Result

      private

      attr_reader compiled_module: CompiledModule
      attr_reader environment_pool: EnvironmentPool
      attr_reader source: String
      def evaluate_with_pool: (input: untyped, data: untyped, query: untyped) -> Result
    end

    module CompiledModuleLike
      def rules_by_name: () -> Hash[String, Array[AST::Rule]]
      def package_path: () -> Array[String]
      def imports: () -> Array[AST::Import]
    end

    type from_ast_options = {
      input?: untyped,
      data?: untyped,
      compiler?: Compiler
    }

    class CompilationArtifacts
      attr_reader rules_by_name: Hash[String, Array[AST::Rule]]
      attr_reader package_path: Array[String]
      attr_reader dependency_graph: Hash[String, Array[String]]

      def initialize: (rules_by_name: Hash[String, Array[AST::Rule]], package_path: Array[String], dependency_graph: Hash[String, Array[String]]) -> void
    end

    class CompiledModule
      include CompiledModuleLike
      attr_reader package_path: Array[String]
      attr_reader rules_by_name: Hash[String, Array[AST::Rule]]
      attr_reader imports: Array[AST::Import]
      attr_reader dependency_graph: Hash[String, Array[String]]

      def initialize: (package_path: Array[String], rules_by_name: Hash[String, Array[AST::Rule]], ?imports: Array[AST::Import], ?dependency_graph: Hash[String, Array[String]]) -> void
      def lookup_rule: (String | Symbol name) -> Array[AST::Rule]
      def rule_names: () -> Array[String]
      def has_rule?: (String | Symbol name) -> bool

      private

      def empty_rules: () -> Array[AST::Rule]
    end

    class CompiledModule::Normalizer
      def initialize: (Hash[Symbol, untyped] state) -> void
      def normalize: () -> [Array[String], Hash[String, Array[AST::Rule]], Array[AST::Import], Hash[String, Array[String]]]

      private

      attr_reader package_path: Array[String]
      attr_reader rules_by_name: Hash[String, Array[AST::Rule]]
      attr_reader imports: Array[AST::Import]
      attr_reader dependency_graph: Hash[String, Array[String]]
      def normalize_rules: () -> Hash[String, Array[AST::Rule]]
      def normalize_dependency_graph: () -> Hash[String, Array[String]]
    end

    class Compiler
      def initialize: (?builtin_registry: Builtins::BuiltinRegistry, ?default_rule_validator: DefaultRuleValidator?) -> void
      def compile: (AST::Module ast_module) -> CompiledModule
      def index_rules: (Array[AST::Rule] rules) -> Hash[String, Array[AST::Rule]]
      def check_conflicts: (Array[AST::Rule] | Hash[String, Array[AST::Rule]] rules) -> void
      def check_safety: (AST::Rule rule) -> void

      private

      def compile_rules: (AST::Module ast_module) -> Hash[String, Array[AST::Rule]]
      def rule_indexer: () -> singleton(RuleIndexer)
      def conflict_checker: () -> ConflictChecker
      def safety_checker: () -> SafetyChecker
      def default_rule_validator: () -> DefaultRuleValidator
      def dependency_graph_builder: () -> DependencyGraphBuilder
      def safe_names_for_imports: (Array[AST::Import] imports) -> Array[String]
      def import_alias_name: (AST::Import import) -> String?
      def validate_import_aliases: (Array[AST::Import] imports, Array[String] rule_names) -> void
      def validate_import_alias: (AST::Import import, Hash[String, bool] seen, Array[String] rule_names) -> void
      def reserved_import_alias?: (String name, AST::Import import) -> bool
      def import_path_exact?: (AST::Import import, String name) -> bool
      def validate_function_name_conflicts: (Hash[String, Array[AST::Rule]] rules_by_name) -> void
      def conflicting_function_rule: (String name, Array[AST::Rule] rules) -> AST::Rule?
      attr_reader builtin_registry: Builtins::BuiltinRegistry
    end

    class RuleGroup
      attr_reader name: String
      attr_reader rules: Array[AST::Rule]

      def initialize: (name: String, rules: Array[AST::Rule]) -> void
      def validate: (singleton(RuleTypeResolver) type_resolver) -> void
      def types: (singleton(RuleTypeResolver) type_resolver) -> Array[Symbol?]
      def complete_rules: () -> Array[AST::Rule]
      def value_rules: () -> Array[AST::Rule]
      def function_rules: () -> Array[AST::Rule]
      def default_rules: () -> Array[AST::Rule]

      private

      def ensure_consistent_types: (singleton(RuleTypeResolver) type_resolver) -> void
      def ensure_complete_rule_consistency: () -> void
      def ensure_function_arity: () -> void
      def ensure_single_default: () -> void
      def function_arities: () -> Array[Integer]
    end

    module RuleIndexer
      def self.index: (Array[AST::Rule] rules) -> Hash[String, Array[AST::Rule]]
    end

    module RuleTypeResolver
      def self.type_for: (AST::Rule rule) -> Symbol?
    end

    class ConflictChecker
      def initialize: (?indexer: singleton(RuleIndexer), ?type_resolver: singleton(RuleTypeResolver)) -> void
      def check: (Array[AST::Rule] | Hash[String, Array[AST::Rule]] rules) -> void

      private

      attr_reader indexer: singleton(RuleIndexer)
      attr_reader type_resolver: singleton(RuleTypeResolver)
      def rule_groups: (Array[AST::Rule] | Hash[String, Array[AST::Rule]] rules) -> Array[RuleGroup]
    end

    module CompiledModuleBuilder
      def self.build: (AST::Module ast_module, CompilationArtifacts artifacts) -> CompiledModule
    end

    class RuleHead
      def initialize: (Hash[Symbol, untyped]? head) -> void
      def type: () -> Symbol?
      def nodes: () -> Array[untyped]
      def function_arg_names: () -> Array[String]

      private

      attr_reader head: Hash[Symbol, untyped]
      def value_nodes: () -> Array[untyped]
      def function_nodes: () -> Array[untyped]
      def function_arg_nodes: () -> Array[untyped]
    end

    class SafetyChecker
      def initialize: (?bound_collector: Evaluator::BoundVariableCollector, ?variable_collector_class: singleton(Evaluator::VariableCollector), ?safe_names: Array[String]) -> void
      def check_rules: (Hash[String, Array[AST::Rule]] rules_by_name, ?safe_names: Array[String]) -> void
      def check_rule: (AST::Rule rule, ?safe_names: Array[String]) -> void

      private

      attr_reader bound_collector: Evaluator::BoundVariableCollector
      attr_reader variable_collector_class: singleton(Evaluator::VariableCollector)
      attr_reader safe_names: Array[String]
    end

    DEFAULT_RULE_CHILD_NODE_EXTRACTORS: Hash[Class, untyped]

    module CallName
      def call_name: (untyped node) -> String?
      def reference_call_name: (AST::Reference reference) -> String?
      def reference_base_name: (AST::Reference reference) -> String?
      def reference_call_segments: (Array[AST::RefArg] path) -> Array[String]?
      def dot_ref_segment_value: (untyped segment) -> String?

      def self.call_name: (untyped node) -> String?
      def self.reference_call_name: (AST::Reference reference) -> String?
      def self.reference_base_name: (AST::Reference reference) -> String?
      def self.reference_call_segments: (Array[AST::RefArg] path) -> Array[String]?
      def self.dot_ref_segment_value: (untyped segment) -> String?
    end

    module DefaultRuleCallName
      def call_name: (untyped node) -> String?
      def reference_call_name: (AST::Reference reference) -> String?
      def reference_base_name: (AST::Reference reference) -> String?
      def reference_call_segments: (Array[AST::RefArg] path) -> Array[String]?
      def dot_ref_segment_value: (untyped segment) -> String?

      def self.call_name: (untyped node) -> String?
      def self.reference_call_name: (AST::Reference reference) -> String?
      def self.reference_base_name: (AST::Reference reference) -> String?
      def self.reference_call_segments: (Array[AST::RefArg] path) -> Array[String]?
      def self.dot_ref_segment_value: (untyped segment) -> String?
    end

    class DefaultRuleValidator
      def initialize: (?child_node_extractors: Hash[Class, untyped], ?builtin_registry: Builtins::BuiltinRegistry) -> void
      def check: (Hash[String, Array[AST::Rule]] rules_by_name) -> void

      private

      attr_reader child_node_extractors: Hash[Class, untyped]
      def contains_variable_or_reference?: (untyped node) -> bool
      def comprehension_value?: (untyped value) -> bool
      def child_nodes: (untyped node) -> Array[untyped]
    end

    class RuleSafetyContext
      attr_reader head: RuleHead
      attr_reader bound_collector: Evaluator::BoundVariableCollector
      attr_reader variable_collector_class: singleton(Evaluator::VariableCollector)
      attr_reader safe_names: Array[String]

      def initialize: (head: RuleHead, bound_collector: Evaluator::BoundVariableCollector, variable_collector_class: singleton(Evaluator::VariableCollector), safe_names: Array[String]) -> void
    end

    class RuleSafetySection
      attr_reader body: untyped
      attr_reader head_nodes: Array[untyped]

      def initialize: (body: untyped, head_nodes: Array[untyped]) -> void
    end

    class RuleSafety
      def initialize: (rule: AST::Rule, context: RuleSafetyContext) -> void
      def check: () -> void

      private

      attr_reader rule: AST::Rule
      attr_reader context: RuleSafetyContext
      def head: () -> RuleHead
      def bound_collector: () -> Evaluator::BoundVariableCollector
      def variable_collector_class: () -> singleton(Evaluator::VariableCollector)
      def safe_names: () -> Array[String]
      def check_body: () -> void
      def check_else_clause: () -> void
      def else_section: () -> RuleSafetySection?
      def else_nodes: (Hash[Symbol, untyped] clause) -> Array[untyped]
      def check_section: (RuleSafetySection section) -> void
      def unbound_variables: (RuleSafetySection section) -> Array[String]
      def bound_variables: (untyped body) -> Array[String]
      def referenced_names: (RuleSafetySection section) -> Array[String]
      def error_message: (Array[String] unbound) -> String
    end

    class DependencyContext
      attr_reader rule_names: Array[String]
      attr_reader package_path: Array[String]

      def initialize: (rule_names: Array[String], package_path: Array[String]) -> void
      def package_depth: () -> Integer
      def package_match?: (Array[untyped] keys) -> bool
      def resolve_rule_name: (Array[untyped] keys) -> String?

      private

      def package_candidate: (Array[untyped] keys) -> String?
      def direct_candidate: (Array[untyped] keys) -> String?
      def rule_name_for: (untyped value) -> String?
    end

    class DependencyGraphBuilder
      def initialize: (?extractor: RuleDependencyExtractor) -> void
      def build: (Hash[String, Array[AST::Rule]] rules_by_name, Array[String] package_path) -> Hash[String, Array[String]]

      private

      attr_reader extractor: RuleDependencyExtractor
    end

    class DependencyGraph
      def initialize: (rules_by_name: Hash[String, Array[AST::Rule]], context: DependencyContext, extractor: RuleDependencyExtractor) -> void
      def build: () -> Hash[String, Array[String]]

      private

      attr_reader rules_by_name: Hash[String, Array[AST::Rule]]
      attr_reader context: DependencyContext
      attr_reader extractor: RuleDependencyExtractor
      def dependencies_for: (Array[AST::Rule] rules) -> Array[String]
    end

    class RuleDependencyExtractor
      def initialize: (?reference_walker: ReferenceWalker, ?resolver: RuleReferenceResolver, ?node_extractor_class: singleton(RuleNodeExtractor)) -> void
      def dependencies_for: (AST::Rule rule, DependencyContext context) -> Array[String]

      private

      attr_reader reference_walker: ReferenceWalker
      attr_reader resolver: RuleReferenceResolver
      attr_reader node_extractor_class: singleton(RuleNodeExtractor)
    end

    class RuleNodeExtractor
      def initialize: (AST::Rule rule) -> void
      def nodes: () -> Array[untyped]

      private

      attr_reader rule: AST::Rule
      attr_reader else_clause: Hash[Symbol, untyped]?
      def base_nodes: () -> Array[untyped]
      def else_nodes: () -> Array[untyped]
    end

    class ReferenceWalker
      NODE_CHILDREN: Hash[Class, untyped]
      NODE_HANDLERS: Hash[Class, untyped]

      def initialize: (?children_extractors: Hash[Class, untyped], ?handlers: Hash[Class, untyped]) -> void
      def references: (untyped nodes) -> Array[AST::Reference]
      def each_reference: (untyped nodes) ?{ (AST::Reference) -> void } -> (Enumerator[AST::Reference] | Array[untyped])
      def walk_children: (untyped node) { (AST::Reference) -> void } -> void

      private

      attr_reader children_extractors: Hash[Class, untyped]
      attr_reader handlers: Hash[Class, untyped]
      def walk: (untyped node) { (AST::Reference) -> void } -> void
      def children_for: (untyped node) -> Array[untyped]
    end

    class RuleReferenceResolver
      def initialize: (?key_extractor: ReferenceKeyExtractor, ?data_root: String) -> void
      def resolve: (AST::Reference ref, DependencyContext context) -> String?

      private

      attr_reader key_extractor: ReferenceKeyExtractor
      attr_reader data_root: String
      def reference_keys: (Array[AST::RefArg] path) -> Array[untyped]
    end

    class ReferenceKeyExtractor
      DEFAULT_EXTRACTORS: Hash[Class, untyped]

      def initialize: (?extractors: Hash[Class, untyped]) -> void
      def extract: (untyped segment) -> untyped?

      private

      attr_reader extractors: Hash[Class, untyped]
    end

    class Evaluator
      attr_reader compiled_module: CompiledModuleLike
      attr_reader environment: Environment

      def self.from_ast: (AST::Module ast_module, ?from_ast_options options) -> Evaluator
      def self.from_environment: (CompiledModuleLike compiled_module, Environment environment) -> Evaluator
      def initialize: (CompiledModuleLike compiled_module, ?input: untyped, ?data: untyped) -> void
      def evaluate: (?untyped query) -> Result

      private
      attr_reader expression_evaluator: Evaluator::ExpressionEvaluator
      attr_reader rule_evaluator: Evaluator::RuleEvaluator
      def evaluate_rules: () -> Hash[untyped, untyped]
      def evaluate_query: (untyped query) -> [Value, Hash[String, Value]]
      def bindings_for_query: (untyped node) -> Hash[String, Value]
      def build_evaluators: (Hash[String, Array[AST::Rule]] rules_by_name, Array[String] package_path) -> [Evaluator::ExpressionEvaluator, Evaluator::RuleEvaluator]
      def build_expression_evaluator: (Evaluator::RuleValueProvider rule_value_provider, Array[String] package_path) -> Evaluator::ExpressionEvaluator
      def build_rule_evaluator: (Evaluator::ExpressionEvaluator expression_evaluator, Evaluator::RuleValueProvider rule_value_provider) -> Evaluator::RuleEvaluator
      def eval_node: (untyped node) -> Value
      def initialize_with_environment: (CompiledModuleLike compiled_module, Environment environment) -> void
    end

    class ResultBuilder
      def initialize: (untyped value, Hash[String, Value]? bindings) -> void
      def build: () -> Result

      private

      attr_reader bindings: Hash[String, Value]?
      attr_reader value: untyped
    end

    class Evaluator::QueryNodeBuilder
      def initialize: (untyped query) -> void
      def build: () -> untyped

      private

      attr_reader query: untyped
      def reference_from_string: () -> AST::Reference
    end

    class Evaluator::RuleValueProvider
      def initialize: (rules_by_name: Hash[String, Array[AST::Rule]], ?memoization: Memoization::Store?) -> void
      def attach: (Evaluator::RuleEvaluator rule_evaluator) -> void
      def value_for: (String name) -> Value
      def rule_defined?: (String name) -> bool

      private

      attr_reader rule_evaluator: Evaluator::RuleEvaluator?
      attr_reader rules_by_name: Hash[String, Array[AST::Rule]]
      attr_reader memoization: Memoization::Store?
      def memoized_value_for: (String name) -> Value
      def evaluate_value_for: (String name) -> Value
    end

    class Evaluator::ReferenceResolver
      UNCACHEABLE: untyped

      class StaticKeyBuilder
        ROOT_NAMES: Array[String]

        def initialize: (AST::Reference reference) -> void
        def call: () -> Array[untyped]?

        private

        attr_reader reference: AST::Reference
        def segment_key: (untyped segment) -> untyped?
      end

      def initialize: (environment: Environment, package_path: Array[String], rule_value_provider: Evaluator::RuleValueProvider, ?imports: Array[AST::Import], ?memoization: Memoization::Store?) -> void
      def resolve: (untyped ref) -> Value
      def resolve_import_variable: (String name) -> Value?
      def resolve_rule_variable: (String name) -> Value?
      def function_reference_name: (AST::Reference reference) -> String?

      private

      def resolve_reference_value: (AST::Reference ref) -> Value
      def resolve_rule_reference: (AST::Reference ref) -> Value?
      def resolve_import_reference: (AST::Reference ref) -> Value?
      def resolve_rule_reference_without_data: (AST::Reference ref) -> Value?
      def import_reference_for: (AST::Reference ref) -> AST::Reference?
      def rule_reference: (Array[AST::RefArg] path) -> [String, Array[AST::RefArg]]?
      def resolve_rule_value: (String rule_name, Array[AST::RefArg] remaining_path) -> Value
      def package_rule_reference: (Array[untyped] keys, Array[AST::RefArg] path) -> [String, Array[AST::RefArg]]?
      def direct_rule_reference: (Array[untyped] keys, Array[AST::RefArg] path) -> [String, Array[AST::RefArg]]?
      def resolve_reference_path: (Value current, Array[AST::RefArg] path) -> Value
      def resolve_reference_path_fast: (Value current, AST::Reference reference) -> Value
      def resolve_reference_path_keys: (Value current, Array[untyped] keys) -> Value
      def resolve_path_segment: (Value current, AST::RefArg segment) -> Value
      def valid_reference_keys: (Array[AST::RefArg] path) -> Array[untyped]?
      def reference_keys: (Array[AST::RefArg] path) -> Array[untyped]
      def package_match?: (Array[untyped] keys) -> bool
      def function_reference_target: (AST::Reference reference) -> AST::Reference
      def resolve_function_reference_name: (AST::Reference reference) -> String?
      def build_import_map: (Array[AST::Import] imports) -> Hash[String, AST::Reference]
      def import_path_segments: (AST::Import import) -> Array[String]
      def build_reference_from_path: (Array[String] path) -> AST::Reference
      def resolve_variable_key: (String name) -> Value
      def cached_reference_value: (AST::Reference reference) -> Value?
      def cache_reference_value: (AST::Reference reference, Value value) -> void
      def reference_cache: () -> Hash[AST::Reference, Value]?
      def cacheable_reference?: (AST::Reference reference) -> bool
      def static_reference_keys: (AST::Reference reference) -> Array[untyped]?

      private

      attr_reader environment: Environment
      attr_reader key_resolver: Evaluator::ReferenceKeyResolver
      attr_reader package_path: Array[String]
      attr_reader rule_value_provider: Evaluator::RuleValueProvider
      attr_reader import_map: Hash[String, AST::Reference]
      attr_reader memoization: Memoization::Store?
    end

    class Evaluator::ReferenceKeyResolver
      def initialize: (environment: Environment, ?variable_resolver: untyped) -> void
      def resolve: (untyped segment) -> untyped

      private

      attr_reader environment: Environment
      attr_reader variable_resolver: untyped
      def resolve_segment: (untyped segment) -> untyped
      def resolve_variable_key: (AST::Variable variable) -> untyped
    end

    class Evaluator::ExpressionEvaluator
      PRIMITIVE_TYPES: Array[Class]
      NODE_EVALUATORS: Array[[Class, ^(untyped, Evaluator::ExpressionEvaluator) -> Value]]
      TRUE_VALUE: BooleanValue
      FALSE_VALUE: BooleanValue

      include Evaluator::AssignmentSupport

      def initialize: (environment: Environment, reference_resolver: Evaluator::ReferenceResolver) -> void
      def attach_query_evaluator: (Evaluator::RuleEvaluator query_evaluator) -> void
      def evaluate: (untyped node) -> Value
      def eval_with_unification: (untyped node, ?Environment env) -> Enumerator[Hash[String, Value]]
      def evaluate_user_function: (String name, Array[Value] args) -> Value

      private

      def evaluate_variable: (AST::Variable node) -> Value
      def resolve_variable_name: (String name) -> Value
      def resolve_reference_variable_key: (String name) -> Value
      def resolve_import_or_rule: (String name, Value fallback) -> Value
      def evaluate_reference: (AST::Reference node) -> Value
      def evaluate_array_literal: (AST::ArrayLiteral node) -> Value
      def evaluate_object_literal: (AST::ObjectLiteral node) -> Value
      def evaluate_set_literal: (AST::SetLiteral node) -> Value
      def evaluate_call: (AST::Call node) -> Value
      def evaluate_template_string: (AST::TemplateString node) -> Value
      def eval_array_comprehension: (AST::ArrayComprehension node) -> Value
      def eval_object_comprehension: (AST::ObjectComprehension node) -> Value
      def eval_set_comprehension: (AST::SetComprehension node) -> Value
      def evaluate_every: (AST::Every node) -> Value
      def evaluate_every_bindings: (AST::Every node, Enumerator[Hash[String, Value]] bindings_enum) -> Value
      def evaluate_binary_op: (AST::BinaryOp node) -> Value
      def evaluate_logical_operator: (AST::BinaryOp node) -> Value
      def evaluate_and_operator: (AST::BinaryOp node) -> Value
      def evaluate_or_operator: (AST::BinaryOp node) -> Value
      def logical_state: (Value value) -> Symbol
      def evaluate_unary_op: (AST::UnaryOp node) -> Value
      def self.call_name: (untyped node) -> String?
      def self.reference_call_name: (AST::Reference reference) -> String?
      def self.reference_base_name: (AST::Reference reference) -> String?
      def self.reference_call_segments: (Array[AST::RefArg] path) -> Array[String]?
      def self.dot_ref_segment_value: (untyped segment) -> String?
      def build_dispatch: () -> Evaluator::ExpressionDispatch
      def handle_unification_operator: (AST::BinaryOp node, Environment env, Enumerator::Yielder yielder) -> void
      def yield_assignment_bindings: (AST::BinaryOp node, Environment env, Enumerator::Yielder yielder) -> void
      def yield_unification_bindings: (AST::BinaryOp node, Environment env, Enumerator::Yielder yielder) -> void
      def yield_truthy_bindings: (untyped node, Enumerator::Yielder yielder) -> void
      def yield_reference_bindings: (AST::Reference node, Environment env, Enumerator::Yielder yielder) -> void
      def format_template_value: (Value value) -> String
      def call_named_function: (String name, untyped name_node, Array[Value] args) -> Value
      def function_name_for_call: (untyped name_node, String fallback_name) -> String
      def every_body_succeeds?: (Array[untyped] body, Hash[String, Value] bindings) -> bool
      def every_bindings: (Array[AST::Variable] variables, Value collection_value) -> Enumerator[Hash[String, Value]]?
      def bindings_for_collection: (Array[AST::Variable] variables, Value collection_value) -> Enumerator[Hash[String, Value]]?
      def array_bindings_for: (Array[AST::Variable] variables, ArrayValue collection_value) -> Enumerator[Hash[String, Value]]?
      def set_bindings_for: (Array[AST::Variable] variables, SetValue collection_value) -> Enumerator[Hash[String, Value]]?
      def object_bindings_for: (Array[AST::Variable] variables, ObjectValue collection_value) -> Enumerator[Hash[String, Value]]?
      def each_array_binding: (Array[AST::Variable] variables, ArrayValue collection_value) -> Enumerator[Hash[String, Value]]
      def each_set_binding: (Array[AST::Variable] variables, SetValue collection_value) -> Enumerator[Hash[String, Value]]
      def each_object_binding: (Array[AST::Variable] variables, ObjectValue collection_value) -> Enumerator[Hash[String, Value]]
      def bindings_for_pair: (Array[AST::Variable] variables, untyped first_value, untyped second_value) -> Hash[String, Value]
      def bindings_for: (AST::Variable variable, untyped value) -> Hash[String, Value]
      def with_every_scope: (AST::Every node) { () -> untyped } -> untyped
      def shadow_every_locals: (AST::Every node) -> void
      def every_variable_names: (AST::Every node) -> Array[String]
      def shadow_explicit_locals: (Array[String] names) -> void
      def shadow_unification_locals: (Array[String] names, Array[String] explicit_names) -> void
      def bind_undefined: (String name) -> void
      def query_evaluator: () -> Evaluator::RuleEvaluator
      def raise_unknown_node: (untyped node) -> Value

      attr_reader environment: Environment
      attr_reader reference_resolver: Evaluator::ReferenceResolver
      attr_reader object_literal_evaluator: Evaluator::ObjectLiteralEvaluator
      attr_reader dispatch: Evaluator::ExpressionDispatch
      attr_reader unifier: Unifier
      attr_reader comprehension_evaluator: Evaluator::ComprehensionEvaluator

    end

    class Evaluator::TemplateValueFormatter
      def initialize: (untyped value) -> void
      def render: () -> String
      def canonical_value: () -> untyped

      private

      attr_reader value: untyped
      def canonicalize_hash: () -> Hash[untyped, untyped]
      def canonicalize_array: () -> Array[untyped]
      def canonicalize_set: () -> Array[untyped]
    end

    module Evaluator::BindingHelpers
      private

      def each_array_binding: (Array[AST::Variable] variables, ArrayValue collection_value) -> Enumerator[Hash[String, Value]]
      def each_set_binding: (Array[AST::Variable] variables, SetValue collection_value) -> Enumerator[Hash[String, Value]]
      def each_object_binding: (Array[AST::Variable] variables, ObjectValue collection_value) -> Enumerator[Hash[String, Value]]
      def bindings_for_pair: (Array[AST::Variable] variables, untyped first_value, untyped second_value) -> Hash[String, Value]
      def bindings_for: (AST::Variable variable, untyped value) -> Hash[String, Value]
    end

    class Evaluator::ComprehensionEvaluator
      class ObjectAccumulator
        def initialize: () -> void
        def add: (Hash[Object, Value] values, untyped key, Value value) -> void

        private

        attr_reader key_sources: Hash[Object, Object]
      end

      class ObjectPairContext
        attr_reader result_values: Hash[Object, Value]
        attr_reader accumulator: ObjectAccumulator

        def initialize: (Hash[Object, Value] result_values, ObjectAccumulator accumulator) -> void
      end

      def initialize: (expression_evaluator: Evaluator::ExpressionEvaluator, environment: Environment) -> void
      def attach_query_evaluator: (Evaluator::RuleEvaluator query_evaluator) -> void
      def eval_array: (AST::ArrayComprehension node) -> Value
      def eval_object: (AST::ObjectComprehension node) -> Value
      def eval_set: (AST::SetComprehension node) -> Value

      private

      def object_pairs: (AST::ObjectComprehension node) -> Hash[Object, Value]
      def apply_object_binding: (ObjectPairContext context, AST::object_term term, Hash[String, Value] bindings) -> void
      def resolve_pair: (AST::object_term term) -> (Array[untyped] | nil)
      def each_comprehension_binding: (Array[untyped] body) { (Hash[String, Value]) -> untyped } -> void
      def collect_values: (AST::ArrayComprehension | AST::SetComprehension node) -> Array[Value]
      def append_value: (Array[Value] values, untyped term, Hash[String, Value] bindings) -> void
      def evaluate_defined_key: (untyped node) -> untyped
      def evaluate_defined_value: (untyped node) -> untyped
      def comprehension_solutions: (Array[untyped] body) -> Enumerator[Hash[String, Value]]
      def with_comprehension_scope: (Array[untyped] body) { () -> untyped } -> untyped
      def shadow_comprehension_locals: (Array[untyped] body) -> void
      def shadow_explicit_locals: (Array[String] names) -> void
      def shadow_unification_locals: (Array[String] names, Array[String] explicit_names) -> void
      def bind_undefined: (String name) -> void

      attr_reader expression_evaluator: Evaluator::ExpressionEvaluator
      attr_reader environment: Environment
      attr_reader query_evaluator: Evaluator::RuleEvaluator?
    end

    module Evaluator::VariableCollectorHelpers
      NODE_COLLECTORS: Hash[Class, untyped]
      CHILDREN_EXTRACTORS: Hash[Class, untyped]

      def self.collector_for: (untyped node) -> untyped
      def self.children_for: (untyped node) -> Array[untyped]
      def self.comprehension_node?: (untyped node) -> bool
    end

    class Evaluator::BoundVariableCollector
      @explicit_names: Array[String]
      @unify_names: Array[String]

      def initialize: () -> void
      def collect: (Array[untyped] literals) -> Array[String]
      def collect_details: (Array[untyped] literals) -> Hash[Symbol, Array[String]]

      private

      attr_reader explicit_names: Array[String]
      attr_reader unify_names: Array[String]
      def reset: () -> void
      def collect_from_literal: (untyped literal) -> void
      def collect_from_expression: (untyped expression) -> void
      def collect_explicit_variables: (untyped node) -> void
      def collect_unification_variables: (untyped node) -> void
      def collect_all_variables: (untyped node, Array[String] target) -> void
    end

    class Evaluator::VariableCollector
      @names: Array[String]
      @local_scopes: Array[Array[String]]

      def initialize: () -> void
      def collect: (untyped node) -> Array[String]
      def collect_literals: (Array[untyped] literals) -> Array[String]

      private

      attr_reader names: Array[String]
      def collect_node: (untyped node) -> void
      def collect_comprehension: (Array[untyped] term_nodes, Array[untyped] body_literals) -> void
      def collect_comprehension_body: (Array[untyped] term_nodes, Array[untyped] body_literals) -> void
      def collect_some_decl: (AST::SomeDecl node) -> void
      def collect_every: (AST::Every node) -> void
      def every_variable_names: (AST::Every node) -> Array[String]
      def add_name: (String name) -> void
      def with_locals: (Array[String] names) { () -> untyped } -> void
      def local_name?: (String name) -> bool
    end

    class Evaluator::ObjectLiteralEvaluator
      def initialize: (expression_evaluator: Evaluator::ExpressionEvaluator) -> void
      def evaluate: (AST::ObjectLiteral node) -> Value

      private

      attr_reader expression_evaluator: Evaluator::ExpressionEvaluator
      def build_pairs: (AST::ObjectLiteral node) -> (Hash[Object, Value] | UndefinedValue)
      def evaluate_key: (untyped key_node) -> untyped
      def resolve_pair: (untyped key_node, untyped value_node) -> (Array[untyped] | UndefinedValue)
    end

    module Evaluator::AssignmentSupport
      private

      def evaluate: (untyped node) -> Value
      def environment: () -> Environment
      def unifier: () -> Unifier
      def reference_resolver: () -> Evaluator::ReferenceResolver
      def evaluate_assignment: (AST::BinaryOp node) -> Value
      def evaluate_unification: (AST::BinaryOp node) -> Value
      def unification_binding_sets: (AST::BinaryOp node, Environment env) -> Array[Hash[String, Value]]
      def unification_result: (AST::BinaryOp node, Environment env) -> [Array[Hash[String, Value]], Value]
      def reference_bindings_for: (AST::Reference reference, Environment env) -> Array[[Hash[String, Value], Value]]
      def reference_base_override: (AST::Reference reference) -> Value?
      def reference_base_name: (AST::Reference reference) -> String?
      def unresolved_reference_base?: (String name) -> bool
      def resolve_reference_base: (String name) -> Value?
      def bind_reference_variable: (AST::Variable variable, Array[[Hash[String, Value], Value]] reference_bindings) -> Array[Hash[String, Value]]
      def apply_bindings: (Hash[String, Value] bindings) -> Hash[String, Value]
    end

    class Evaluator::ExpressionDispatch
      def initialize: (primitive_types: Array[Class], node_evaluators: Array[[Class, ^(untyped, Evaluator::ExpressionEvaluator) -> Value]]) -> void
      def primitive_value: (untyped node) -> Value?
      def dispatch_node: (untyped node, Evaluator::ExpressionEvaluator evaluator) -> Value?

      private

      attr_reader primitive_types: Array[Class]
      attr_reader node_evaluators: Array[[Class, ^(untyped, Evaluator::ExpressionEvaluator) -> Value]]
      attr_reader handler_cache: Hash[Class, (^(untyped, Evaluator::ExpressionEvaluator) -> Value)?]
      def handler_for: (untyped node) -> (^(untyped, Evaluator::ExpressionEvaluator) -> Value)?
    end

    class Evaluator::RuleEvaluator
      class QueryContext
        attr_reader literals: Array[untyped]
        attr_reader env: Environment

        def initialize: (literals: Array[untyped], env: Environment) -> void
      end

      class ModifierContext
        attr_reader expression: untyped
        attr_reader env: Environment
        attr_reader bound_vars: Array[String]

        def initialize: (expression: untyped, env: Environment, bound_vars: Array[String]) -> void
        def with_env: (Environment new_env) -> ModifierContext
      end

      class ValueEvaluationContext
        attr_reader body: Array[untyped]?
        attr_reader rule: AST::Rule
        attr_reader value_node: untyped
        attr_reader initial_bindings: Hash[String, Value]

        def initialize: (body: Array[untyped]?, rule: AST::Rule, value_node: untyped, initial_bindings: Hash[String, Value]) -> void
      end

      def initialize: (environment: Environment, expression_evaluator: Evaluator::ExpressionEvaluator) -> void
      def evaluate_group: (Array[AST::Rule] rules) -> Value
      def evaluate_rule: (AST::Rule rule) -> Value
      def evaluate_function_call: (String name, Array[Value] args) -> Value
      def query_solutions: (Array[untyped] literals, ?Environment env) -> Enumerator[Hash[String, Value]]

      private

      def evaluate_function_call_uncached: (String name, Array[Value] args) -> Value
      def evaluate_partial_set_rules: (Array[AST::Rule] rules) -> Value
      def evaluate_partial_object_rules: (Array[AST::Rule] rules) -> Value
      def partial_object_pairs: (Array[AST::Rule] rules) -> Hash[Object, Value]
      def merge_partial_object_value: (Value? existing, Value value, untyped key, bool existing_nested, bool current_nested) -> Value
      def merge_object_value_hash: (Hash[Object, Value] left, Hash[Object, Value] right, untyped key) -> Hash[Object, Value]
      def merge_object_value_value: (Value? existing, Value value, untyped key) -> Value
      def evaluate_complete_rules: (Array[AST::Rule] rules) -> Value
      def evaluate_partial_object_value: (untyped head) -> untyped
      def evaluate_complete_rule_value: (untyped head, ?untyped value_node) -> Value
      def complete_rule_value_with_else: (AST::Rule rule) -> Value
      def else_clause_value: (AST::Rule rule, untyped clause) -> Value
      def evaluate_value_with_body: (ValueEvaluationContext context) -> Array[Value]
      def values_for_body_context: (ValueEvaluationContext context) -> Array[Value]
      def evaluate_value_node: (AST::Rule rule, untyped value_node) -> Value?
      def empty_bindings: () -> Hash[String, Value]
      def evaluate_clause_value: (AST::Rule rule, untyped clause, Hash[String, Value] bindings) -> Array[Value]
      def function_values_with_else: (AST::Rule rule, Hash[String, Value] bindings) -> Array[Value]
      def function_else_values: (AST::Rule rule, untyped clause, Hash[String, Value] bindings) -> Array[Value]
      def resolve_conflicts: (Array[Value] values, String name) -> Value?
      def evaluate_function_rules: (Array[AST::Rule] rules, Array[Value] args) -> Array[Value]
      def function_rule_values: (AST::Rule rule, Array[Value] args) -> Array[Value]
      def body_succeeds?: (Array[untyped]? body) -> bool
      def query_literal_truthy?: (untyped literal) -> bool
      def some_decl_truthy?: (AST::SomeDecl literal) -> bool
      def evaluate_rule_value: (untyped head) -> Value
      def rule_body_values: (AST::Rule rule, ?Hash[String, Value] initial_bindings) -> Array[Value]
      def rule_body_pairs: (AST::Rule rule) -> Array[[Object, Value, bool]]
      def eval_rule_body: (Array[untyped]? body, Environment env) -> Enumerator[Hash[String, Value]]
      def eval_query: (Array[untyped] literals, Environment env) -> Enumerator[Hash[String, Value]]
      def with_query_scope: (Environment env, Array[untyped] literals) { () -> untyped } -> untyped
      def shadow_query_locals: (Environment env, Array[untyped] literals) -> void
      def shadow_explicit_locals: (Environment env, Array[String] names) -> void
      def shadow_unification_locals: (Environment env, Array[String] names, Array[String] explicit_names) -> void
      def bind_undefined: (Environment env, String name) -> void
      def yield_query_solutions: (Enumerator::Yielder yielder, QueryContext context, Integer index, Hash[String, Value] bindings, Array[String] bound_vars) -> void
      def eval_literal: (untyped literal, Environment env, Array[String] bound_vars) -> Enumerator[Hash[String, Value]]
      def eval_query_literal: (AST::QueryLiteral literal, Environment env, Array[String] bound_vars) -> Enumerator[Hash[String, Value]]
      def eval_query_expression: (untyped expression, Environment env, Array[String] bound_vars) -> Enumerator[Hash[String, Value]]
      def with_modifiers_enum: (Array[AST::WithModifier] modifiers, ModifierContext context) -> Enumerator[Hash[String, Value]]
      def yield_query_expression: (Enumerator::Yielder yielder, ModifierContext context) -> void
      def eval_not: (untyped expr, Environment env, Array[String] bound_vars) -> Enumerator[Hash[String, Value]]
      def check_safety: (untyped expr, Environment env, Array[String] bound_vars) -> void
      def raise_unsafe_negation: (untyped expr, Array[String] unbound) -> void
      def unbound_variables: (Array[String] names, Environment env, Array[String] bound_vars) -> Array[String]
      def env_bound?: (Environment env, String name) -> bool
      def eval_some_decl: (AST::SomeDecl literal, ?Environment env) -> Enumerator[Hash[String, Value]]
      def yield_empty_bindings: (Enumerator::Yielder yielder) -> void
      def each_some_solution: (AST::SomeDecl literal) -> Enumerator[Hash[String, Value]]
      def collection_bindings: (Array[AST::Variable] variables, Value collection_value) -> Enumerator[Hash[String, Value]]
      def each_array_binding: (Array[AST::Variable] variables, ArrayValue collection_value) -> Enumerator[Hash[String, Value]]
      def each_set_binding: (Array[AST::Variable] variables, SetValue collection_value) -> Enumerator[Hash[String, Value]]
      def each_object_binding: (Array[AST::Variable] variables, ObjectValue collection_value) -> Enumerator[Hash[String, Value]]
      def bindings_for_pair: (Array[AST::Variable] variables, untyped first_value, untyped second_value) -> Hash[String, Value]
      def bindings_for: (AST::Variable variable, untyped value) -> Hash[String, Value]
      def merge_bindings: (Hash[String, Value] existing, Hash[String, Value] additions) -> Hash[String, Value]?
      def empty_bindings_enum: () -> Enumerator[Hash[String, Value]]
      def memoization: () -> Memoization::Store

      attr_reader environment: Environment
      attr_reader expression_evaluator: Evaluator::ExpressionEvaluator
      attr_reader unifier: Unifier
    end

    module Evaluator::OperatorEvaluator
      EQUALITY_OPERATORS: Hash[Symbol, ^(untyped, untyped) -> Value]
      LOGICAL_OPERATORS: Hash[Symbol, ^(Value, Value) -> Value]
      COMPARISON_OPERATORS: Hash[Symbol, ^(untyped, untyped) -> bool]
      ARITHMETIC_OPERATORS: Hash[Symbol, ^(untyped, untyped) -> untyped]
      MEMBERSHIP_OPERATORS: Hash[Symbol, ^(Value, Value) -> Value]
      UNARY_OPERATORS: Hash[Symbol, ^(Value) -> Value]

      def self.apply: (Symbol operator, Value left, Value right) -> Value
      def self.apply_unary: (Symbol operator, Value operand) -> Value
      def self.apply_logical: (Symbol operator, Value left, Value right) -> Value?
      def self.apply_comparison: (Symbol operator, Value left, Value right) -> Value?
      def self.apply_arithmetic: (Symbol operator, Value left, Value right) -> Value?
      def self.compare_values: (Value left, Value right) { (untyped, untyped) -> bool } -> Value
      def self.comparable?: (untyped left_value, untyped right_value) -> bool
      def self.arithmetic_values: (Symbol operator, Value left, Value right) { (untyped, untyped) -> untyped } -> Value
      def self.numeric_value: (Value value) -> Numeric?
      def self.division_by_zero?: (Symbol operator, Numeric right_value) -> bool
      def self.undefined_operand?: (Value lhs, Value rhs) -> bool
      def self.collection_values: (Value value) -> (Array[Value] | UndefinedValue)
      def self.membership_value: (Value lhs, Value rhs) -> Value
    end

    module TokenType
      PACKAGE: Symbol
      IMPORT: Symbol
      AS: Symbol
      DEFAULT: Symbol
      IF: Symbol
      CONTAINS: Symbol
      SOME: Symbol
      IN: Symbol
      EVERY: Symbol
      NOT: Symbol
      AND: Symbol
      OR: Symbol
      WITH: Symbol
      ELSE: Symbol
      TRUE: Symbol
      FALSE: Symbol
      NULL: Symbol
      DATA: Symbol
      INPUT: Symbol

      ASSIGN: Symbol
      EQ: Symbol
      NEQ: Symbol
      LT: Symbol
      LTE: Symbol
      GT: Symbol
      GTE: Symbol
      PLUS: Symbol
      MINUS: Symbol
      STAR: Symbol
      SLASH: Symbol
      PERCENT: Symbol
      PIPE: Symbol
      AMPERSAND: Symbol
      UNIFY: Symbol

      LPAREN: Symbol
      RPAREN: Symbol
      LBRACKET: Symbol
      RBRACKET: Symbol
      LBRACE: Symbol
      RBRACE: Symbol
      DOT: Symbol
      COMMA: Symbol
      SEMICOLON: Symbol
      COLON: Symbol
      UNDERSCORE: Symbol

      STRING: Symbol
      TEMPLATE_STRING: Symbol
      NUMBER: Symbol
      RAW_STRING: Symbol
      RAW_TEMPLATE_STRING: Symbol
      IDENT: Symbol

      EOF: Symbol
      NEWLINE: Symbol
      COMMENT: Symbol

      KEYWORDS: Array[Symbol]
      OPERATORS: Array[Symbol]
      DELIMITERS: Array[Symbol]
      LITERALS: Array[Symbol]
      SPECIALS: Array[Symbol]

      def self.keyword?: (Symbol type) -> bool
      def self.operator?: (Symbol type) -> bool
      def self.literal?: (Symbol type) -> bool
    end

    class Token
      attr_reader type: Symbol
      attr_reader value: untyped
      attr_reader location: Location?

      def initialize: (type: Symbol, ?value: untyped, ?location: Location?) -> void
      def keyword?: () -> bool
      def operator?: () -> bool
      def literal?: () -> bool
      def to_s: () -> String
    end

    class Lexer
      KEYWORDS: Hash[String, Symbol]
      SINGLE_CHAR_TOKENS: Hash[String, Symbol]
      COMPOUND_TOKENS: Hash[String, [Symbol?, Symbol]]
      NEWLINE_CHARS: Array[String]
      WHITESPACE_CHARS: Array[String]
      EXPONENT_CHARS: Array[String]
      SIGN_CHARS: Array[String]
      IDENTIFIER_START: Regexp
      IDENTIFIER_PART: Regexp
      DIGIT: Regexp
      HEX_DIGIT: Regexp
      TEMPLATE_ESCAPE: String

      def initialize: (String source) -> void
      def tokenize: () -> Array[Token]

      private

      def next_token: () -> Token
      def eof_token: () -> Token
      def simple_token_for: (String char) -> Token?
      def read_compound_token: (String char) -> Token?
      def skip_whitespace: () -> void
      def skip_comment: () -> void
      def read_number: () -> Token
      def read_number_prefix: () -> String
      def read_fractional_part: () -> String
      def read_exponent_part: () -> String
      def read_exponent_sign: () -> String
      def read_string: () -> Token
      def read_raw_string: () -> Token
      def read_template_string: () -> Token
      def read_standard_template_string: (position start) -> Token
      def read_raw_template_string: (position start) -> Token
      def read_newline: () -> Token
      def read_identifier: () -> Token
      def read_digits: () -> String
      def read_escape_sequence: (position backslash_position) -> String
      def read_unicode_escape: () -> String
      def parse_number: (String buffer, position start) -> Numeric
      def template_string_start?: (String char) -> bool
      def advance: () -> String
      def advance_line_break: () -> String
      def advance_newline: () -> String
      def increment_line: (Integer count) -> void
      def increment_position: (Integer count) -> void
      def peek: (?Integer distance) -> String?
      def match?: (String expected) -> bool
      def current_char: () -> String?
      def eof?: () -> bool
      def capture_position: () -> position
      def build_token: (Symbol type, untyped value, position start) -> Token
      def identifier_start?: (String? char) -> bool
      def identifier_part?: (String? char) -> bool
      def digit?: (String? char) -> bool
      def hex_digit?: (String? char) -> bool
      def whitespace?: (String? char) -> bool
      def newline?: (String? char) -> bool
      def exponent_start?: () -> bool
      def span_length_from: (position start) -> Integer
      def raise_unterminated_string: (position start) -> bot
      def raise_unterminated_raw_string: (position start) -> bot
      def raise_unexpected_eof: () -> bot
      def raise_error: (String message, position position, length: Integer?) -> bot

      private

      attr_reader source: String
      attr_reader position: Integer
      attr_reader line: Integer
      attr_reader column: Integer
      attr_reader offset: Integer
    end

    class Parser
      IDENTIFIER_TOKEN_TYPES: Array[Symbol]
      IDENTIFIER_TOKEN_NAMES: Hash[Symbol, String]
      PACKAGE_PATH_TOKEN_TYPES: Array[Symbol]
      IMPORT_PATH_TOKEN_TYPES: Array[Symbol]
      BINARY_OPERATOR_MAP: Hash[Symbol, Symbol]
      UNARY_OPERATOR_MAP: Hash[Symbol, Symbol]
      PRIMARY_PARSERS: Hash[Symbol, Symbol]

      @tokens: Array[Token]
      @current: Integer
      @errors: Array[ParserError]

      def initialize: (Array[Token] tokens) -> void
      def parse: () -> AST::Module
      def self.parse_expression_from_string: (String source) -> AST::expression

      private

      def tokens: () -> Array[Token]
      def current_token: () -> Token
      def current_index: () -> Integer
      def peek: (?Integer distance) -> Token
      def advance: () -> Token
      def consume: (Symbol type, ?String message) -> Token
      def match?: (*Symbol types) -> bool
      def pipe_token?: () -> bool
      def rbrace_token?: () -> bool
      def newline_token?: () -> bool
      def consume_newlines: () -> void
      def at_end?: () -> bool
      def parse_error: (String message) -> bot
      def synchronize: () -> void
      def parse_module: () -> AST::Module
      def parse_statement: (Array[AST::Import] imports, Array[AST::Rule] rules) -> void
      def parse_package: () -> AST::Package
      def parse_import: () -> AST::Import
      def parse_import_alias: () -> String?
      def parse_rule: () -> AST::Rule
      def consume_default_keyword: () -> Token?
      def parse_rule_name_path: () -> [String, Array[AST::expression]]
      def parse_rule_head_segments: (Parser::IdentifierContext context) -> Array[AST::expression]
      def parse_rule_head_segment: (Parser::IdentifierContext context, Array[AST::expression] segments) -> AST::expression?
      def parse_dot_rule_head_segment: (Parser::IdentifierContext context) -> AST::expression
      def parse_bracket_rule_head_segment: (Array[AST::expression] segments) -> AST::expression?
      def mark_default_head: (Hash[Symbol, untyped] head) -> Hash[Symbol, untyped]
      def parse_default_value: (Token? default_token, Hash[Symbol, untyped] head) -> AST::expression?
      def parse_non_default_body: (Token? default_token) -> Array[AST::query_literal]?
      def parse_rule_definition: (Token? default_token, Hash[Symbol, untyped] head) -> Hash[Symbol, untyped]
      def parse_else_clause_for_definition: (Token? default_token) -> Hash[Symbol, untyped]?
      def validate_rule_definition: (Token? default_token, Hash[Symbol, untyped] head, Hash[Symbol, untyped] definition) -> void
      def parse_else_clause_if_present: () -> Hash[Symbol, untyped]?
      def build_rule_node: (name: String, head: Hash[Symbol, untyped], name_token: Token, definition: Hash[Symbol, untyped]) -> AST::Rule
      def parse_rule_head: (String name, Token name_token) -> Hash[Symbol, untyped]
      def parse_contains_rule_head: (String name, Token name_token) -> Hash[Symbol, untyped]
      def parse_function_rule_head: (String name, Token name_token) -> Hash[Symbol, untyped]
      def parse_bracket_rule_head: (String name, Token name_token) -> Hash[Symbol, untyped]
      def parse_partial_object_rule_head: (String name, Token name_token, AST::expression key) -> Hash[Symbol, untyped]
      def build_rule_head: (Symbol type, String name, Token name_token, **untyped attrs) -> Hash[Symbol, untyped]
      def parse_rule_head_args: () -> Array[AST::expression]
      def parse_rule_head_key: () -> AST::expression
      def parse_rule_value: () -> AST::expression?
      def parse_rule_body: () -> Array[AST::query_literal]
      def parse_braced_rule_body: () -> Array[AST::query_literal]
      def parse_empty_rule_body: () -> Array[AST::query_literal]
      def apply_rule_head_path: (Hash[Symbol, untyped] head, Array[AST::expression] segments, Token name_token) -> Hash[Symbol, untyped]
      def nested_rule_head: (Hash[Symbol, untyped] head, Array[AST::expression] segments, Token name_token) -> Hash[Symbol, untyped]
      def rule_head_path_builder: (Hash[Symbol, untyped] head, Array[AST::expression] segments, Token name_token) -> Parser::RuleHeadPathBuilder
      def rule_head_location: (Token name_token) -> Location
      def bracket_expression_followed_by_path?: () -> bool
      def matching_bracket_index: (Integer start_index) -> Integer?
      def next_non_newline_token: (Integer start_index) -> Token
      def bracket_matcher: () -> Parser::BracketMatcher
      def parse_rule_head_path_segment: () -> AST::expression
      def parse_query: (*Symbol end_tokens, ?newline_delimiter: bool) -> Array[AST::query_literal]
      def consume_query_separators: (bool newline_delimiter) -> bool
      def parse_literal: () -> AST::query_literal
      def parse_some_decl: () -> AST::SomeDecl
      def parse_every: () -> AST::Every
      def parse_some_variables: () -> Array[AST::Variable]
      def parse_some_collection: () -> AST::expression?
      def parse_every_variables: () -> [AST::Variable?, AST::Variable]
      def parse_every_domain: () -> AST::expression
      def parse_every_body: () -> Array[AST::query_literal]
      def parse_with_modifier: () -> AST::WithModifier
      def parse_with_modifiers: () -> Array[AST::WithModifier]
      def parse_else_clause: () -> Hash[Symbol, untyped]
      def parse_expression: (?Integer precedence) -> AST::expression
      def parse_infix_expression: (AST::expression left, Integer precedence) -> AST::expression
      def infix_operator?: (Integer precedence) -> bool
      def parse_primary: () -> AST::expression
      def parse_infix: (AST::expression left, Token operator_token) -> AST::BinaryOp
      def parse_reference: (AST::expression base) -> AST::Reference
      def parse_array: () -> AST::expression
      def parse_object: (Token start_token, AST::expression first_key, AST::expression first_value) -> AST::ObjectLiteral
      def build_object_pairs: (AST::expression first_key, AST::expression first_value) -> Array[[AST::expression, AST::expression]]
      def parse_set: (Token start_token, ?AST::expression first_element) -> AST::SetLiteral
      def parse_array_comprehension: (Token start_token, AST::expression term) -> AST::ArrayComprehension
      def parse_object_comprehension: (Token start_token, AST::expression key, AST::expression value) -> AST::ObjectComprehension
      def parse_set_comprehension: (Token start_token, AST::expression term) -> AST::SetComprehension
      def parse_comprehension: (Token start_token, untyped term, Symbol end_token, [String, String] messages, untyped node_class) -> untyped
      def parse_call_args: () -> Array[AST::expression]
      def parse_string_literal: () -> AST::StringLiteral
      def parse_template_string: () -> AST::TemplateString
      def parse_template_parts: (Token token) -> Array[untyped]
      def append_template_literal: (Array[untyped] parts, String literal, Location? location) -> void
      def normalize_template_literal: (String literal) -> String
      def find_template_expression_end: (String text, Integer start_index) -> Integer
      def parse_number_literal: () -> AST::NumberLiteral
      def parse_boolean_literal: () -> AST::BooleanLiteral
      def parse_null_literal: () -> AST::NullLiteral
      def parse_unary_expression: () -> AST::UnaryOp
      def parse_parenthesized_expression: () -> AST::expression
      def parse_parenthesized_body: () -> AST::expression
      def parse_parenthesized_expression_list: (open_message: String, close_message: String) -> Array[AST::expression]
      def parse_path: (Parser::IdentifierContext identifier_context) -> Array[String]
      def parse_path_segment: (Parser::IdentifierContext identifier_context) -> String
      def parse_bracket_path_segment: () -> String?
      def bracket_string_segment?: () -> bool
      def parse_identifier: (Parser::IdentifierContext identifier_context) -> String
      def parse_braced_literal: () -> AST::expression
      def parse_object_literal_or_comprehension: (Token start_token, AST::expression key) -> AST::expression
      def parse_identifier_expression: () -> AST::expression
      def parse_variable: () -> AST::Variable
      def parse_expression_list_until: (Symbol end_token) -> Array[AST::expression]
      def parse_expression_list_until_with_first: (Symbol end_token, AST::expression first_element) -> Array[AST::expression]
      def append_expression_list: (Array[AST::expression] elements, Symbol end_token) -> void
      def parse_object_pair: (AST::expression key) -> [AST::expression, AST::expression]
      def append_object_pairs: (Array[[AST::expression, AST::expression]] pairs) -> void
      def empty_set?: (AST::expression?) -> bool
      def empty_object_literal: (Token start_token) -> AST::ObjectLiteral
      def empty_set_literal: (Token start_token) -> AST::SetLiteral
      def parse_reference_path: (Array[AST::RefArg] path) -> void
      def parse_dot_reference: (Array[AST::RefArg] path) -> void
      def parse_bracket_reference: (Array[AST::RefArg] path) -> void
      def safe_token_at: (Integer index) -> Token
      def record_error: (ParserError error) -> void

      private

      def errors: () -> Array[ParserError]
    end

    class Parser::IdentifierContext
      attr_reader name: String
      attr_reader allowed_types: Array[Symbol]

      def initialize: (name: String, allowed_types: Array[Symbol]) -> void
    end

    class Parser::RuleHeadPathBuilder
      def initialize: (head: Hash[Symbol, untyped], segments: Array[AST::expression], location: Location?) -> void
      def call: () -> Hash[Symbol, untyped]

      private

      attr_reader head: Hash[Symbol, untyped]
      attr_reader segments: Array[AST::expression]
      attr_reader location: Location?
      def build_nested_value: (Array[AST::expression] segments, AST::expression value_node) -> AST::expression
      def normalize: (AST::expression segment) -> AST::expression
    end

    class Parser::BracketMatcher
      BRACKET_DEPTH_DELTA: Hash[Symbol, Integer]

      def initialize: (token_provider: ^(Integer) -> Token) -> void
      def matching_index: (Integer start_index) -> Integer?

      private

      attr_reader token_provider: ^(Integer) -> Token
    end

    class Parser
      module Precedence
        LOWEST: Integer
        ASSIGNMENT: Integer
        OR: Integer
        AND: Integer
        EQUALS: Integer
        COMPARE: Integer
        SUM: Integer
        PRODUCT: Integer
        UNARY: Integer
        BINARY: Hash[Symbol, Integer]
      end
    end

    class Parser
      module Helpers
        def self.precedence_of: (Symbol operator) -> Integer
        def self.normalize_reference_base: (AST::expression base) -> [AST::expression, Array[AST::RefArg]]
        def self.variable_name_for: (Token token) -> String
      end
    end

    module AST
      class Base
        attr_reader location: Location?

        def initialize: (?location: Location?) -> void
        def accept: (untyped visitor) -> untyped
        def deconstruct_keys: (Array[Symbol]? keys) -> Hash[Symbol, untyped]
        def to_s: () -> String
        def ==: (untyped other) -> bool
        def eql?: (untyped other) -> bool
        def hash: () -> Integer
        def self.format_value: (untyped value) -> String

        private

        def deconstruct_attributes: () -> Hash[Symbol, untyped]
        def deconstructable_keys: () -> Array[Symbol]
      end

      type expression = Literal | TemplateString | Variable | Reference | BinaryOp | UnaryOp | ArrayLiteral | ObjectLiteral | SetLiteral | ArrayComprehension | ObjectComprehension | SetComprehension | Every | Call
      type call_name = String | Variable | Reference
      type query_literal = QueryLiteral | SomeDecl
      type query = Array[query_literal]
      type object_term = [expression, expression]

      class Literal < Base
        attr_reader value: untyped

        def initialize: (value: untyped, ?location: Location?) -> void
      end

      class StringLiteral < Literal
        attr_reader value: String

        def initialize: (value: String, ?location: Location?) -> void
      end

      class TemplateString < Base
        attr_reader parts: Array[untyped]

        def initialize: (parts: Array[untyped], ?location: Location?) -> void
      end

      class NumberLiteral < Literal
        attr_reader value: Numeric

        def initialize: (value: Numeric, ?location: Location?) -> void
      end

      class BooleanLiteral < Literal
        attr_reader value: bool

        def initialize: (value: bool, ?location: Location?) -> void
      end

      class NullLiteral < Literal
        attr_reader value: nil

        def initialize: (?location: Location?) -> void
      end

      class Variable < Base
        attr_reader name: String

        def initialize: (name: String, ?location: Location?) -> void
      end

      class Reference < Base
        attr_reader base: expression
        attr_reader path: Array[RefArg]

        def initialize: (base: expression, path: Array[RefArg], ?location: Location?) -> void
      end

      class RefArg < Base
        attr_reader value: untyped

        def initialize: (value: untyped, ?location: Location?) -> void
      end

      class DotRefArg < RefArg
        def initialize: (value: untyped, ?location: Location?) -> void
      end

      class BracketRefArg < RefArg
        def initialize: (value: untyped, ?location: Location?) -> void
      end

      class BinaryOp < Base
        OPERATORS: Array[Symbol]

        attr_reader operator: Symbol
        attr_reader left: expression
        attr_reader right: expression

        def initialize: (operator: Symbol, left: expression, right: expression, ?location: Location?) -> void

        private

        def validate_operator: () -> bool
        def validate_operator!: () -> void
      end

      class UnaryOp < Base
        OPERATORS: Array[Symbol]

        attr_reader operator: Symbol
        attr_reader operand: expression

        def initialize: (operator: Symbol, operand: expression, ?location: Location?) -> void

        private

        def validate_operator: () -> bool
        def validate_operator!: () -> void
      end

      class ArrayLiteral < Base
        attr_reader elements: Array[expression]

        def initialize: (elements: Array[expression], ?location: Location?) -> void
      end

      class ObjectLiteral < Base
        attr_reader pairs: Array[[expression, expression]]

        def initialize: (pairs: Array[[expression, expression]], ?location: Location?) -> void
      end

      class SetLiteral < Base
        attr_reader elements: Array[expression]

        def initialize: (elements: Array[expression], ?location: Location?) -> void
      end

      class ArrayComprehension < Base
        attr_reader term: expression
        attr_reader body: query

        def initialize: (term: expression, body: query, ?location: Location?) -> void
      end

      class ObjectComprehension < Base
        attr_reader term: object_term
        attr_reader body: query

        def initialize: (term: object_term, body: query, ?location: Location?) -> void
      end

      class SetComprehension < Base
        attr_reader term: expression
        attr_reader body: query

        def initialize: (term: expression, body: query, ?location: Location?) -> void
      end

      class Every < Base
        attr_reader key_var: Variable?
        attr_reader value_var: Variable
        attr_reader domain: expression
        attr_reader body: query

        def initialize: (value_var: Variable, domain: expression, body: query, key_var: Variable?, ?location: Location?) -> void
      end

      class QueryLiteral < Base
        attr_reader expression: expression
        attr_reader with_modifiers: Array[WithModifier]

        def initialize: (expression: expression, ?with_modifiers: Array[WithModifier], ?location: Location?) -> void
      end

      class SomeDecl < Base
        attr_reader variables: Array[Variable]
        attr_reader collection: expression?

        def initialize: (variables: Array[Variable], ?collection: expression?, ?location: Location?) -> void
      end

      class WithModifier < Base
        attr_reader target: expression
        attr_reader value: expression

        def initialize: (target: expression, value: expression, ?location: Location?) -> void
      end

      class Call < Base
        attr_reader name: call_name
        attr_reader args: Array[expression]

        def initialize: (name: call_name, args: Array[expression], ?location: Location?) -> void
      end

      class Module < Base
        attr_reader package: Package
        attr_reader imports: Array[Import]
        attr_reader rules: Array[Rule]

        def initialize: (package: Package, imports: Array[Import], rules: Array[Rule], ?location: Location?) -> void
      end

      class Package < Base
        attr_reader path: Array[String]

        def initialize: (path: Array[String], ?location: Location?) -> void
      end

      class Import < Base
        attr_reader path: Array[String] | String
        attr_reader alias: String?

        def initialize: (path: Array[String] | String, ?alias_name: String?, ?location: Location?) -> void
        def alias_name: () -> String?
      end

      class Rule < Base
        RULE_TYPE_LOOKUP: Array[Symbol]
        Definition: untyped

        attr_reader name: String
        attr_reader head: untyped
        attr_reader body: untyped
        attr_reader default_value: untyped
        attr_reader else_clause: untyped

        def initialize: (name: String, ?head: untyped, ?body: untyped, ?default_value: untyped, ?else_clause: untyped, ?location: Location?) -> void
        def complete?: () -> bool
        def partial_set?: () -> bool
        def partial_object?: () -> bool
        def function?: () -> bool

        private

        def rule_type: () -> Symbol?
        def resolve_rule_type: () -> (String | Symbol | nil)
        def type_from_object: () -> untyped
        def type_from_hash: () -> untyped
        attr_reader definition: untyped
      end
    end
  end
end
