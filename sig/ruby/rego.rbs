module Ruby
  module Rego
    VERSION: String

    type position = {
      line: Integer,
      column: Integer,
      offset: Integer?,
      length: Integer?
    }

    module ErrorFormatting
      def self.format_details: (Hash[Symbol, untyped]) -> String
    end

    class Location
      attr_reader line: Integer
      attr_reader column: Integer
      attr_reader offset: Integer?
      attr_reader length: Integer?

      def self.from: (Location | position) -> Location
      def initialize: (line: Integer, column: Integer, ?offset: Integer?, ?length: Integer?) -> void
      def to_s: () -> String
    end

    class Error < StandardError
      attr_reader location: Location?

      def initialize: (?String message, location: Location?) -> void

      private

      def compose_message: (String? message) -> String
    end

    class LexerError < Error
      attr_reader line: Integer
      attr_reader column: Integer

      def initialize: (String message, line: Integer, column: Integer, offset: Integer?, length: Integer?) -> void
    end

    class ParserError < Error
      attr_reader line: Integer
      attr_reader column: Integer
      attr_reader context: String?

      def initialize: (String message, location: Location, context: String?) -> void
      def self.from_position: (String message, position: position | Location, context: String?) -> ParserError
    end

    class EvaluationError < Error
      attr_reader rule: untyped

      def initialize: (String message, rule: untyped, location: Location?) -> void
    end

    class TypeError < Error
      attr_reader expected: untyped
      attr_reader actual: untyped
      attr_reader context: String?

      def initialize: (String message, expected: untyped, actual: untyped, context: String?, location: Location?) -> void
    end

    class UnificationError < Error
      attr_reader pattern: untyped
      attr_reader value: untyped

      def initialize: (String message, pattern: untyped, value: untyped, location: Location?) -> void
    end

    module TokenType
      PACKAGE: Symbol
      IMPORT: Symbol
      AS: Symbol
      DEFAULT: Symbol
      IF: Symbol
      CONTAINS: Symbol
      SOME: Symbol
      IN: Symbol
      EVERY: Symbol
      NOT: Symbol
      WITH: Symbol
      ELSE: Symbol
      TRUE: Symbol
      FALSE: Symbol
      NULL: Symbol
      DATA: Symbol
      INPUT: Symbol

      ASSIGN: Symbol
      EQ: Symbol
      NEQ: Symbol
      LT: Symbol
      LTE: Symbol
      GT: Symbol
      GTE: Symbol
      PLUS: Symbol
      MINUS: Symbol
      STAR: Symbol
      SLASH: Symbol
      PERCENT: Symbol
      PIPE: Symbol
      AMPERSAND: Symbol
      UNIFY: Symbol

      LPAREN: Symbol
      RPAREN: Symbol
      LBRACKET: Symbol
      RBRACKET: Symbol
      LBRACE: Symbol
      RBRACE: Symbol
      DOT: Symbol
      COMMA: Symbol
      SEMICOLON: Symbol
      COLON: Symbol
      UNDERSCORE: Symbol

      STRING: Symbol
      NUMBER: Symbol
      RAW_STRING: Symbol
      IDENT: Symbol

      EOF: Symbol
      NEWLINE: Symbol
      COMMENT: Symbol

      KEYWORDS: Array[Symbol]
      OPERATORS: Array[Symbol]
      DELIMITERS: Array[Symbol]
      LITERALS: Array[Symbol]
      SPECIALS: Array[Symbol]

      def self.keyword?: (Symbol type) -> bool
      def self.operator?: (Symbol type) -> bool
      def self.literal?: (Symbol type) -> bool
    end

    class Token
      attr_reader type: Symbol
      attr_reader value: untyped
      attr_reader location: Location?

      def initialize: (type: Symbol, ?value: untyped, ?location: Location?) -> void
      def keyword?: () -> bool
      def operator?: () -> bool
      def literal?: () -> bool
      def to_s: () -> String
    end

    class Lexer
      KEYWORDS: Hash[String, Symbol]
      SINGLE_CHAR_TOKENS: Hash[String, Symbol]
      NEWLINE_CHARS: Array[String]
      WHITESPACE_CHARS: Array[String]
      EXPONENT_CHARS: Array[String]
      SIGN_CHARS: Array[String]
      IDENTIFIER_START: Regexp
      IDENTIFIER_PART: Regexp
      DIGIT: Regexp
      HEX_DIGIT: Regexp

      def initialize: (String source) -> void
      def tokenize: () -> Array[Token]

      private

      def next_token: () -> Token
      def eof_token: () -> Token
      def simple_token_for: (String char) -> Token?
      def read_colon_or_assign: () -> Token
      def read_equal_or_unify: () -> Token
      def read_not_equal: () -> Token
      def read_lt_or_lte: () -> Token
      def read_gt_or_gte: () -> Token
      def skip_whitespace: () -> void
      def skip_comment: () -> void
      def read_number: () -> Token
      def read_string: () -> Token
      def read_raw_string: () -> Token
      def read_identifier: () -> Token
      def read_digits: () -> String
      def read_escape_sequence: (position backslash_position) -> String
      def read_unicode_escape: () -> String
      def parse_number: (String buffer, position start) -> Numeric
      def advance: () -> String
      def advance_line_break: () -> String
      def advance_newline: () -> String
      def increment_line: (Integer count) -> void
      def increment_position: (Integer count) -> void
      def peek: (?Integer distance) -> String?
      def match?: (String expected) -> bool
      def current_char: () -> String?
      def eof?: () -> bool
      def capture_position: () -> position
      def build_token: (Symbol type, untyped value, position start) -> Token
      def identifier_start?: (String? char) -> bool
      def identifier_part?: (String? char) -> bool
      def digit?: (String? char) -> bool
      def hex_digit?: (String? char) -> bool
      def whitespace?: (String? char) -> bool
      def newline?: (String? char) -> bool
      def exponent_start?: () -> bool
      def span_length_from: (position start) -> Integer
      def raise_unterminated_string: (position start) -> bot
      def raise_unterminated_raw_string: (position start) -> bot
      def raise_unexpected_eof: () -> bot
      def raise_error: (String message, position position, length: Integer?) -> bot

      private

      attr_reader source: String
      attr_reader position: Integer
      attr_reader line: Integer
      attr_reader column: Integer
      attr_reader offset: Integer
    end

    module AST
      class Base
        attr_reader location: Location?

        def initialize: (?location: Location?) -> void
        def accept: (untyped visitor) -> untyped
        def to_s: () -> String
        def ==: (untyped other) -> bool
        def eql?: (untyped other) -> bool
        def hash: () -> Integer
        def self.format_value: (untyped value) -> String
      end

      type expression = Literal | Variable | Reference | BinaryOp | UnaryOp | ArrayLiteral | ObjectLiteral | SetLiteral | ArrayComprehension | ObjectComprehension | SetComprehension | Call
      type call_name = String | Variable | Reference
      type query = Array[expression]

      class Literal < Base
        attr_reader value: untyped

        def initialize: (value: untyped, ?location: Location?) -> void
      end

      class StringLiteral < Literal
        attr_reader value: String

        def initialize: (value: String, ?location: Location?) -> void
      end

      class NumberLiteral < Literal
        attr_reader value: Numeric

        def initialize: (value: Numeric, ?location: Location?) -> void
      end

      class BooleanLiteral < Literal
        attr_reader value: bool

        def initialize: (value: bool, ?location: Location?) -> void
      end

      class NullLiteral < Literal
        attr_reader value: nil

        def initialize: (?location: Location?) -> void
      end

      class Variable < Base
        attr_reader name: String

        def initialize: (name: String, ?location: Location?) -> void
      end

      class Reference < Base
        attr_reader base: expression
        attr_reader path: Array[RefArg]

        def initialize: (base: expression, path: Array[RefArg], ?location: Location?) -> void
      end

      class RefArg < Base
        attr_reader value: untyped

        def initialize: (value: untyped, ?location: Location?) -> void
      end

      class DotRefArg < RefArg
        def initialize: (value: untyped, ?location: Location?) -> void
      end

      class BracketRefArg < RefArg
        def initialize: (value: untyped, ?location: Location?) -> void
      end

      class BinaryOp < Base
        OPERATORS: Array[Symbol]

        attr_reader operator: Symbol
        attr_reader left: expression
        attr_reader right: expression

        def initialize: (operator: Symbol, left: expression, right: expression, ?location: Location?) -> void

        private

        def validate_operator: () -> bool
        def validate_operator!: () -> void
      end

      class UnaryOp < Base
        OPERATORS: Array[Symbol]

        attr_reader operator: Symbol
        attr_reader operand: expression

        def initialize: (operator: Symbol, operand: expression, ?location: Location?) -> void

        private

        def validate_operator: () -> bool
        def validate_operator!: () -> void
      end

      class ArrayLiteral < Base
        attr_reader elements: Array[expression]

        def initialize: (elements: Array[expression], ?location: Location?) -> void
      end

      class ObjectLiteral < Base
        attr_reader pairs: Array[[expression, expression]]

        def initialize: (pairs: Array[[expression, expression]], ?location: Location?) -> void
      end

      class SetLiteral < Base
        attr_reader elements: Array[expression]

        def initialize: (elements: Array[expression], ?location: Location?) -> void
      end

      class ArrayComprehension < Base
        attr_reader term: expression
        attr_reader body: query

        def initialize: (term: expression, body: query, ?location: Location?) -> void
      end

      class ObjectComprehension < Base
        attr_reader term: expression
        attr_reader body: query

        def initialize: (term: expression, body: query, ?location: Location?) -> void
      end

      class SetComprehension < Base
        attr_reader term: expression
        attr_reader body: query

        def initialize: (term: expression, body: query, ?location: Location?) -> void
      end

      class Call < Base
        attr_reader name: call_name
        attr_reader args: Array[expression]

        def initialize: (name: call_name, args: Array[expression], ?location: Location?) -> void
      end

      class Module < Base
        attr_reader package: Package
        attr_reader imports: Array[Import]
        attr_reader rules: Array[Rule]

        def initialize: (package: Package, imports: Array[Import], rules: Array[Rule], ?location: Location?) -> void
      end

      class Package < Base
        attr_reader path: Array[String]

        def initialize: (path: Array[String], ?location: Location?) -> void
      end

      class Import < Base
        attr_reader path: untyped
        attr_reader alias: String?

        def initialize: (path: untyped, ?alias_name: String?, ?location: Location?) -> void
        def alias_name: () -> String?
      end

      class Rule < Base
        RULE_TYPE_LOOKUP: Array[Symbol]
        Definition: untyped

        attr_reader name: String
        attr_reader head: untyped
        attr_reader body: untyped
        attr_reader default_value: untyped
        attr_reader else_clause: untyped

        def initialize: (name: String, ?head: untyped, ?body: untyped, ?default_value: untyped, ?else_clause: untyped, ?location: Location?) -> void
        def complete?: () -> bool
        def partial_set?: () -> bool
        def partial_object?: () -> bool
        def function?: () -> bool

        private

        def rule_type: () -> Symbol?
        def resolve_rule_type: () -> (String | Symbol | nil)
        def type_from_object: () -> untyped
        def type_from_hash: () -> untyped
        attr_reader definition: untyped
      end
    end
  end
end
