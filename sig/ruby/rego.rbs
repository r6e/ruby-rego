module Ruby
  module Rego
    VERSION: String

    type position = {
      line: Integer,
      column: Integer,
      offset: Integer?,
      length: Integer?
    }

    module ErrorFormatting
      def self.format_details: (Hash[Symbol, untyped]) -> String
    end

    class Location
      attr_reader line: Integer
      attr_reader column: Integer
      attr_reader offset: Integer?
      attr_reader length: Integer?

      def self.from: (Location | position) -> Location
      def initialize: (line: Integer, column: Integer, ?offset: Integer?, ?length: Integer?) -> void
      def to_s: () -> String
    end

    class Error < StandardError
      attr_reader location: Location?

      def initialize: (?String message, location: Location?) -> void

      private

      def compose_message: (String? message) -> String
    end

    class LexerError < Error
      attr_reader line: Integer
      attr_reader column: Integer

      def initialize: (String message, line: Integer, column: Integer, offset: Integer?, length: Integer?) -> void
    end

    class ParserError < Error
      attr_reader line: Integer
      attr_reader column: Integer
      attr_reader context: String?

      def initialize: (String message, location: Location, context: String?) -> void
      def self.from_position: (String message, position: position | Location, context: String?) -> ParserError
    end

    class EvaluationError < Error
      attr_reader rule: untyped

      def initialize: (String message, rule: untyped, location: Location?) -> void
    end

    class TypeError < Error
      attr_reader expected: untyped
      attr_reader actual: untyped
      attr_reader context: String?

      def initialize: (String message, expected: untyped, actual: untyped, context: String?, location: Location?) -> void
    end

    class UnificationError < Error
      attr_reader pattern: untyped
      attr_reader value: untyped

      def initialize: (String message, pattern: untyped, value: untyped, location: Location?) -> void
    end

    module TokenType
      PACKAGE: Symbol
      IMPORT: Symbol
      AS: Symbol
      DEFAULT: Symbol
      IF: Symbol
      CONTAINS: Symbol
      SOME: Symbol
      IN: Symbol
      EVERY: Symbol
      NOT: Symbol
      WITH: Symbol
      ELSE: Symbol
      TRUE: Symbol
      FALSE: Symbol
      NULL: Symbol
      DATA: Symbol
      INPUT: Symbol

      ASSIGN: Symbol
      EQ: Symbol
      NEQ: Symbol
      LT: Symbol
      LTE: Symbol
      GT: Symbol
      GTE: Symbol
      PLUS: Symbol
      MINUS: Symbol
      STAR: Symbol
      SLASH: Symbol
      PERCENT: Symbol
      PIPE: Symbol
      AMPERSAND: Symbol
      UNIFY: Symbol

      LPAREN: Symbol
      RPAREN: Symbol
      LBRACKET: Symbol
      RBRACKET: Symbol
      LBRACE: Symbol
      RBRACE: Symbol
      DOT: Symbol
      COMMA: Symbol
      SEMICOLON: Symbol
      COLON: Symbol
      UNDERSCORE: Symbol

      STRING: Symbol
      NUMBER: Symbol
      RAW_STRING: Symbol
      IDENT: Symbol

      EOF: Symbol
      NEWLINE: Symbol
      COMMENT: Symbol

      KEYWORDS: Array[Symbol]
      OPERATORS: Array[Symbol]
      DELIMITERS: Array[Symbol]
      LITERALS: Array[Symbol]
      SPECIALS: Array[Symbol]

      def self.keyword?: (Symbol type) -> bool
      def self.operator?: (Symbol type) -> bool
      def self.literal?: (Symbol type) -> bool
    end

    class Token
      attr_reader type: Symbol
      attr_reader value: untyped
      attr_reader location: Location?

      def initialize: (type: Symbol, ?value: untyped, ?location: Location?) -> void
      def keyword?: () -> bool
      def operator?: () -> bool
      def literal?: () -> bool
      def to_s: () -> String
    end

    class Lexer
      KEYWORDS: Hash[String, Symbol]
      SINGLE_CHAR_TOKENS: Hash[String, Symbol]
      NEWLINE_CHARS: Array[String]
      WHITESPACE_CHARS: Array[String]
      EXPONENT_CHARS: Array[String]
      SIGN_CHARS: Array[String]
      IDENTIFIER_START: Regexp
      IDENTIFIER_PART: Regexp
      DIGIT: Regexp
      HEX_DIGIT: Regexp

      def initialize: (String source) -> void
      def tokenize: () -> Array[Token]

      private

      def next_token: () -> Token
      def eof_token: () -> Token
      def simple_token_for: (String char) -> Token?
      def read_colon_or_assign: () -> Token
      def read_equal_or_unify: () -> Token
      def read_not_equal: () -> Token
      def read_lt_or_lte: () -> Token
      def read_gt_or_gte: () -> Token
      def skip_whitespace: () -> void
      def skip_comment: () -> void
      def read_number: () -> Token
      def read_string: () -> Token
      def read_raw_string: () -> Token
      def read_identifier: () -> Token
      def read_digits: () -> String
      def read_escape_sequence: (position backslash_position) -> String
      def read_unicode_escape: () -> String
      def parse_number: (String buffer, position start) -> Numeric
      def advance: () -> String
      def advance_line_break: () -> String
      def advance_newline: () -> String
      def increment_line: (Integer count) -> void
      def increment_position: (Integer count) -> void
      def peek: (?Integer distance) -> String?
      def match?: (String expected) -> bool
      def current_char: () -> String?
      def eof?: () -> bool
      def capture_position: () -> position
      def build_token: (Symbol type, untyped value, position start) -> Token
      def identifier_start?: (String? char) -> bool
      def identifier_part?: (String? char) -> bool
      def digit?: (String? char) -> bool
      def hex_digit?: (String? char) -> bool
      def whitespace?: (String? char) -> bool
      def newline?: (String? char) -> bool
      def exponent_start?: () -> bool
      def span_length_from: (position start) -> Integer
      def raise_unterminated_string: (position start) -> bot
      def raise_unterminated_raw_string: (position start) -> bot
      def raise_unexpected_eof: () -> bot
      def raise_error: (String message, position position, length: Integer?) -> bot

      private

      attr_reader source: String
      attr_reader position: Integer
      attr_reader line: Integer
      attr_reader column: Integer
      attr_reader offset: Integer
    end
  end
end
