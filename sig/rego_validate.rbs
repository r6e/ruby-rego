module RegoValidate
  class Options
    attr_accessor policy: String?
    attr_accessor config: String?
    attr_accessor query: String?
    attr_accessor format: String
    attr_accessor help: bool
    attr_accessor yaml_aliases: bool
    attr_accessor profile: bool

    def initialize: (?policy: String?, ?config: String?, ?query: String?, ?format: String, ?help: bool, ?yaml_aliases: bool, ?profile: bool) -> void
    def help?: () -> bool
    def profile?: () -> bool
  end

  class ParseResult
    attr_reader options: Options
    attr_reader parser: untyped
    attr_reader error: OptionParser::ParseError?

    def initialize: (options: Options, parser: untyped, ?error: OptionParser::ParseError?) -> void
    def success?: () -> bool

    def report_error: (stdout: IO, stderr: IO) -> void

    private

    def error_message: () -> String
  end

  class ConfigLoadResult
    attr_reader value: untyped
    attr_reader success: bool

    def initialize: (?value: untyped, success: bool) -> void
    def success?: () -> bool
  end

  class EvaluationResult
    attr_reader outcome: Outcome?
    attr_reader error_message: String?

    def initialize: (?outcome: Outcome?, ?error_message: String?) -> void
    def success?: () -> bool
  end

  class Outcome
    attr_reader success: bool
    attr_reader value: untyped
    attr_reader errors: Array[String]

    def initialize: (success: bool, value: untyped, errors: Array[String]) -> void
    def success?: () -> bool
  end

  class CLI
    def initialize: (Array[String] argv, ?stdout: IO, ?stderr: IO) -> void
    def run: () -> Integer

    private

    attr_reader argv: Array[String]
    attr_reader options: Options
    attr_reader stdout: IO
    attr_reader stderr: IO
    def perform_run: () -> Integer
    def apply_parse_result: (ParseResult parse_result) -> Integer
    def handle_evaluation: (untyped parser) -> Integer
    def emit_outcome: (Outcome outcome) -> Integer
    def handle_parse_error: (ParseResult parse_result) -> Integer
    def required_options_present?: (untyped parser) -> bool
    def evaluate_policy: (untyped parser, ?profiler: Profiler?) -> EvaluationResult
    def report_evaluation_error: (EvaluationResult evaluation, untyped parser) -> void
    def handle_help: (untyped parser) -> Integer
    def handle_rego_error: (Ruby::Rego::Error error) -> Integer
    def handle_unexpected_error: (StandardError error) -> Integer
    def reporter: () -> ErrorReporter
  end

  class OptionsParser
    VALID_FORMATS: Array[String]

    def initialize: (Array[String] argv) -> void
    def parse: () -> ParseResult

    class ParseResultBuilder
      def initialize: (Array[String] argv) -> void
      def call: () -> ParseResult

      private

      attr_reader argv: Array[String]
      def parse_with: (Options options) -> ParseResult
    end

    class OptionDefinitions
      OPTION_BUILDERS: Array[Symbol]

      def initialize: (Options options) -> void
      def build: () -> OptionParser

      private

      attr_reader options: Options
      def apply_options: (OptionParser opts) -> void
      def add_policy_option: (OptionParser opts) -> void
      def add_config_option: (OptionParser opts) -> void
      def add_query_option: (OptionParser opts) -> void
      def add_format_option: (OptionParser opts) -> void
      def add_profile_option: (OptionParser opts) -> void
      def add_yaml_aliases_option: (OptionParser opts) -> void
      def add_help_option: (OptionParser opts) -> void
    end

    private

    attr_reader argv: Array[String]
  end

  class OptionsValidator
    def initialize: (Options options) -> void
    def missing_required: () -> Array[String]

    private

    attr_reader options: Options
  end

  class ConfigLoader
    JSON_EXTENSIONS: Array[String]

    def initialize: (reporter: ErrorReporter, parser: untyped, yaml_aliases: bool) -> void
    def read_policy: (String path) -> String?
    def read_config: (String path) -> ConfigLoadResult

    private

    attr_reader reporter: ErrorReporter
    attr_reader parser: untyped
    attr_reader json_extensions: Array[String]
    attr_reader yaml_aliases: bool
    def read_file: (String path, String label) -> String?
    def parse_config: (String content, String path) -> ConfigLoadResult
    def parse_config_value: (String content, String path) -> untyped
    def report_file_error: (String label, String reason, String path) -> void
    def json_config?: (String path) -> bool
  end

  class SourceLoader
    def initialize: (options: Options, reporter: ErrorReporter, parser: untyped) -> void
    def load: () -> [String?, ConfigLoadResult]

    private

    attr_reader options: Options
    attr_reader loader: ConfigLoader
    def load_policy_source: () -> String?
    def load_config: () -> ConfigLoadResult
  end

  class DefaultQueryResolver
    DEFAULT_RULE_NAMES: Array[String]
    FALLBACK_RULE_NAMES: Array[String]

    def initialize: (Ruby::Rego::CompiledModule compiled_module) -> void
    def resolve: () -> String?

    private

    attr_reader compiled_module: Ruby::Rego::CompiledModule
    attr_reader rule_names: Array[String]
    def rule_available?: (String name) -> bool
    def package_path: () -> Array[String]
  end

  class PolicyEvaluator
    def initialize: (String policy_source, untyped input, String? query, ?profiler: Profiler?) -> void
    def evaluate: () -> EvaluationResult

    private

    attr_reader policy_source: String
    attr_reader input: untyped
    attr_reader query: String?
    attr_reader profiler: Profiler?
    def resolve_query: (Ruby::Rego::CompiledModule compiled_module) -> String?
    def build_evaluation: (Ruby::Rego::CompiledModule compiled_module, String query_path) -> EvaluationResult
    def evaluate_compiled: (Ruby::Rego::CompiledModule compiled_module, String query_path) -> Ruby::Rego::Result
    def measure: (String label) { () -> untyped } -> untyped
  end

  class Profiler
    class Sample
      attr_reader label: String
      attr_reader duration_ms: Float
      attr_reader allocations: Integer
      attr_reader memory_bytes: Integer
      attr_reader top_objects: Array[String]

      def initialize: (label: String, duration_ms: Float, allocations: Integer, memory_bytes: Integer, top_objects: Array[String]) -> void
      def report_line: () -> String
      def top_objects_line: () -> String?

      private

      def format_duration: () -> String
      def format_bytes: () -> String
    end

    class ByteFormatter
      def initialize: (Integer bytes) -> void
      def render: () -> String

      private

      attr_reader sign: String
      attr_reader size: Integer
    end

    class Snapshot
      def self.capture: () -> Snapshot
      def self.capture_before: () -> Snapshot
      def self.capture_after: () -> Snapshot
      def initialize: (allocated: Integer, memsize: Integer, objects: Hash[Symbol, Integer]) -> void
      def delta: (Snapshot other) -> Delta
      attr_reader allocated: Integer
      attr_reader memsize: Integer
      attr_reader objects: Hash[Symbol, Integer]

      private

      def self.build_snapshot: (memsize: Integer, objects: Hash[Symbol, Integer]) -> Snapshot
      def self.empty_object_counts: () -> Hash[Symbol, Integer]

      def object_delta_map: (Hash[Symbol, Integer] after_objects) -> Hash[Symbol, Integer]
      def add_delta: (Hash[Symbol, Integer] deltas, Symbol key, Integer count) -> void
    end

    class Delta
      SKIP_KEYS: Array[Symbol]

      def self.skip_key?: (Symbol key) -> bool
      def initialize: (allocations: Integer, memory_bytes: Integer, object_deltas: Hash[Symbol, Integer]) -> void
      def top_objects: (?limit: Integer) -> Array[String]

      attr_reader allocations: Integer
      attr_reader memory_bytes: Integer
      attr_reader object_deltas: Hash[Symbol, Integer]
    end

    class Measurement
      def initialize: (label: String, before: Snapshot, start: Float) -> void
      def finish: (after: Snapshot, finish: Float) -> Sample

      private

      attr_reader before: Snapshot
      attr_reader label: String
      attr_reader start: Float
    end

    def initialize: (?stderr: IO) -> void
    def measure: (String label) { () -> untyped } -> untyped
    def report: () -> void

    private

    attr_reader clock: untyped
    attr_reader samples: Array[Profiler::Sample]
    attr_reader stderr: IO
    def report_samples: () -> void
    def report_hotspot: () -> void
    def start_measurement: (String label) -> Measurement
    def finish_measurement: (Measurement measurement) -> void
    def clock_time: () -> Float
  end

  class OutcomeBuilder
    def initialize: (Ruby::Rego::Result result, String query) -> void
    def build: () -> Outcome

    private

    attr_reader result: Ruby::Rego::Result
    attr_reader query: String
    def build_defined_outcome: () -> Outcome
    def errors_for: (untyped value) -> Array[String]
    def undefined_outcome: () -> Outcome
    def errors_from_value: (untyped value) -> Array[String]
    def errors_for_non_true: (untyped value) -> Array[String]
    def scalar_error: (untyped value) -> Array[String]
    def collection_errors: (untyped value) -> Array[String]
    def hash_errors: (untyped value) -> Array[String]
    def format_rule_error: (untyped value) -> String
    def rule_name: () -> String
  end

  class OutcomeEmitter
    def initialize: (IO stdout, ?format: String) -> void
    def emit: (Outcome outcome) -> void

    class JsonFormatter
      def initialize: (IO stdout) -> void
      def emit: (Outcome outcome) -> void

      private

      attr_reader stdout: IO
    end

    class TextFormatter
      def initialize: (IO stdout) -> void
      def emit: (Outcome outcome) -> void

      private

      attr_reader stdout: IO
    end

    class OutcomePayload
      def initialize: (Outcome outcome) -> void
      def to_h: () -> Hash[Symbol, untyped]

      private

      attr_reader outcome: Outcome
      def normalize_json: (untyped value) -> untyped
      def normalize_array: (Array[untyped] values) -> Array[untyped]
      def normalize_hash: (Hash[untyped, untyped] values) -> Hash[untyped, untyped]
      def normalize_set: (Set[untyped] values) -> Array[untyped]
    end

    FORMATTERS: Hash[String, untyped]

    private

    attr_reader formatter: untyped
  end

  class ErrorReporter
    def initialize: (stdout: IO, stderr: IO, ?format: String) -> void
    def error: (String message, ?untyped parser) -> void
    def rego_error: (Ruby::Rego::Error error) -> void

    class ErrorPayload
      def self.from_cli_error: (String message) -> ErrorPayload
      def self.from_rego_error: (Ruby::Rego::Error error) -> ErrorPayload
      def initialize: (message: String, type: String, ?location: Ruby::Rego::Location?) -> void
      def to_h: () -> Hash[Symbol, untyped]

      private

      attr_reader message: String
      attr_reader type: String
      attr_reader location: Ruby::Rego::Location?
    end

    class JsonFormatter
      def initialize: (stdout: IO, stderr: IO) -> void
      def error: (String message, ?untyped parser) -> void
      def rego_error: (Ruby::Rego::Error error) -> void

      private

      attr_reader stdout: IO
      attr_reader stderr: IO
    end

    class TextFormatter
      def initialize: (stdout: IO, stderr: IO) -> void
      def error: (String message, ?untyped parser) -> void
      def rego_error: (Ruby::Rego::Error error) -> void

      private

      attr_reader stdout: IO
      attr_reader stderr: IO
    end

    FORMATTERS: Hash[String, untyped]
  end
end
