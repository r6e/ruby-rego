#!/usr/bin/env ruby
# frozen_string_literal: true

require "json"
require "optparse"
require "yaml"
require "ruby/rego"

module RegoValidate
  Options = Struct.new(:policy, :config, :query, :format, :help, keyword_init: true) do
    def help?
      help
    end
  end

  ParseResult = Struct.new(:options, :parser, :error, keyword_init: true) do
    def success?
      error.nil?
    end
  end

  # Captures the outcome of loading a config file.
  ConfigLoadResult = Struct.new(:value, :success, keyword_init: true) do
    def success?
      success
    end
  end

  EvaluationResult = Struct.new(:outcome, :error_message, keyword_init: true) do
    def success?
      error_message.nil? && !outcome.nil?
    end
  end

  Outcome = Struct.new(:success, :value, :errors, keyword_init: true) do
    def success?
      success
    end
  end

  # Command-line interface for validating inputs against a Rego policy.
  class CLI
    def initialize(argv, stdout: $stdout, stderr: $stderr)
      @argv = argv
      @stdout = stdout
      @reporter = ErrorReporter.new(stdout: stdout, stderr: stderr)
      @options = Options.new(format: "text", help: false)
    end

    def run
      perform_run
    rescue Ruby::Rego::Error => e
      reporter.rego_error(e, format: options.format)
      2
    rescue StandardError => e
      reporter.error("Unexpected error: #{e.message}", format: options.format)
      2
    end

    private

    attr_reader :argv, :reporter, :options, :stdout

    def perform_run
      parse_result = parse_options
      return handle_parse_error(parse_result) unless parse_result.success?

      @options = parse_result.options
      return handle_help(parse_result.parser) if options.help?
      return 2 unless required_options_present?(parse_result.parser)

      handle_evaluation(parse_result.parser)
    end

    def parse_options
      OptionsParser.new(argv).parse
    end

    def handle_evaluation(parser)
      evaluation = evaluate_policy(parser)
      return 2 unless evaluation.success?

      emit_outcome(evaluation.outcome)
    end

    def emit_outcome(outcome)
      OutcomeEmitter.new(stdout).emit(outcome, format: options.format)
      outcome.success? ? 0 : 1
    end

    def handle_parse_error(parse_result)
      reporter.error(parse_result.error.message, parse_result.parser, format: parse_result.options.format)
      2
    end

    def required_options_present?(parser)
      missing = OptionsValidator.new(options).missing_required
      return true if missing.empty?

      reporter.error("Missing required options: #{missing.join(", ")}", parser, format: options.format)
      false
    end

    def evaluate_policy(parser)
      policy_source, config_result = load_sources(parser)
      return EvaluationResult.new unless policy_source && config_result.success?

      evaluation = PolicyEvaluator.new(policy_source, config_result.value, options.query).evaluate
      report_evaluation_error(evaluation, parser)
      evaluation
    end

    def load_sources(parser)
      loader = ConfigLoader.new(reporter: reporter, parser: parser, format: options.format)
      policy_source = loader.read_policy(options.policy)
      return [nil, ConfigLoadResult.new(success: false)] unless policy_source

      config_result = loader.read_config(options.config)
      [policy_source, config_result]
    end

    def report_evaluation_error(evaluation, parser)
      return if evaluation.error_message.nil?

      reporter.error(evaluation.error_message, parser, format: options.format)
    end

    def handle_help(parser)
      if options.format == "json"
        stdout.puts(JSON.generate({ success: true, help: parser.to_s }))
      else
        stdout.puts(parser)
      end
      0
    end
  end

  # Parses CLI arguments into a structured options object.
  class OptionsParser
    VALID_FORMATS = %w[text json].freeze

    def initialize(argv)
      @argv = argv
    end

    def parse
      options = Options.new(format: "text", help: false)
      parser = build_parser(options)
      parser.parse!(@argv)
      ParseResult.new(options: options, parser: parser)
    rescue OptionParser::ParseError => e
      ParseResult.new(options: options, parser: parser, error: e)
    end

    private

    attr_reader :argv

    def build_parser(options)
      OptionParser.new do |opts|
        opts.banner = "Usage: rego-validate --policy POLICY_FILE --config CONFIG_FILE [options]"
        add_policy_option(opts, options)
        add_config_option(opts, options)
        add_query_option(opts, options)
        add_format_option(opts, options)
        add_help_option(opts, options)
      end
    end

    def add_policy_option(opts, options)
      opts.on("--policy FILE", "Rego policy file (required)") do |file|
        options.policy = file
      end
    end

    def add_config_option(opts, options)
      opts.on("--config FILE", "YAML/JSON config file (required)") do |file|
        options.config = file
      end
    end

    def add_query_option(opts, options)
      opts.on("--query QUERY", "Query path (optional, defaults to violations/errors)") do |query|
        options.query = query
      end
    end

    def add_format_option(opts, options)
      message = "Output format: #{VALID_FORMATS.join(", ")} (default: text)"
      opts.on("--format FORMAT", VALID_FORMATS, message) do |format|
        options.format = format
      end
    end

    def add_help_option(opts, options)
      opts.on("-h", "--help", "Show this help") do
        options.help = true
      end
    end
  end

  # Checks presence of required CLI options.
  class OptionsValidator
    def initialize(options)
      @options = options
    end

    def missing_required
      missing = []
      missing << "--policy" unless options.policy
      missing << "--config" unless options.config
      missing
    end

    private

    attr_reader :options
  end

  # Loads policy and input configuration files.
  class ConfigLoader
    def initialize(reporter:, parser:, format:)
      @reporter = reporter
      @parser = parser
      @format = format
    end

    def read_policy(path)
      read_file(path, "policy")
    end

    def read_config(path)
      content = read_file(path, "config")
      return ConfigLoadResult.new(success: false) unless content

      parse_config(content, path)
    end

    private

    attr_reader :reporter, :parser, :format

    def read_file(path, label)
      File.read(path)
    rescue Errno::ENOENT
      reporter.error("#{label.capitalize} file not found: #{path}", parser, format: format)
      nil
    rescue Errno::EACCES
      reporter.error("#{label.capitalize} file not readable: #{path}", parser, format: format)
      nil
    end

    def parse_config(content, path)
      value = json_file?(path) ? JSON.parse(content) : YAML.safe_load(content, aliases: true)
      ConfigLoadResult.new(value: value, success: true)
    rescue JSON::ParserError, Psych::SyntaxError => e
      reporter.error("Invalid config file: #{e.message}", parser, format: format)
      ConfigLoadResult.new(success: false)
    end

    def json_file?(path)
      File.extname(path).downcase == ".json"
    end
  end

  # Compiles and evaluates policies with a resolved query.
  class PolicyEvaluator
    DEFAULT_RULE_NAMES = %w[deny violations violation errors error].freeze
    FALLBACK_RULE_NAMES = %w[allow].freeze

    def initialize(policy_source, input, query)
      @policy_source = policy_source
      @input = input
      @query = query
    end

    def evaluate
      compiled_module = Ruby::Rego.compile(policy_source)
      query_path = query || default_query(compiled_module)
      return EvaluationResult.new(error_message: "No default validation rule found. Provide --query.") unless query_path

      result = evaluate_compiled(compiled_module, query_path)
      outcome = OutcomeBuilder.new(result, query_path).build
      EvaluationResult.new(outcome: outcome)
    end

    private

    attr_reader :policy_source, :input, :query

    def evaluate_compiled(compiled_module, query_path)
      Ruby::Rego::Evaluator.new(compiled_module, input: input).evaluate(query_path)
    rescue Ruby::Rego::Error => e
      raise e
    rescue StandardError => e
      raise Ruby::Rego::Error.new("Rego evaluation failed: #{e.message}", location: error_location(e)), cause: e
    end

    def error_location(error)
      location = error.respond_to?(:location) ? error.location : nil
      return location if location

      line = error.respond_to?(:line) ? error.line : nil
      column = error.respond_to?(:column) ? error.column : nil
      return Ruby::Rego::Location.new(line: line, column: column) if line.is_a?(Integer) && column.is_a?(Integer)

      nil
    end

    def default_query(compiled_module)
      rule_name = default_rule_name(compiled_module)
      return nil unless rule_name

      base = ["data", *compiled_module.package_path].join(".")
      "#{base}.#{rule_name}"
    end

    def default_rule_name(compiled_module)
      (DEFAULT_RULE_NAMES + FALLBACK_RULE_NAMES).find do |name|
        compiled_module.has_rule?(name)
      end
    end
  end

  # Builds a normalized outcome payload from evaluation results.
  class OutcomeBuilder
    def initialize(result, query)
      @result = result
      @query = query
    end

    def build
      return undefined_outcome if result.undefined?

      build_defined_outcome
    end

    private

    attr_reader :result, :query

    def build_defined_outcome
      value = result.value.to_ruby
      errors = errors_for(value)
      Outcome.new(success: errors.empty?, value: value, errors: errors)
    end

    def errors_for(value)
      errors = errors_from_value(value)
      errors.concat(result.errors.map(&:to_s)) unless result.errors.empty?
      errors
    end

    def undefined_outcome
      Outcome.new(success: false, value: nil, errors: [format_rule_error("undefined")])
    end

    def errors_from_value(value)
      return [] if value == true
      return [format_rule_error(value)] if falsy_scalar?(value)
      return collection_errors(value) if collection?(value)
      return hash_errors(value) if value.is_a?(Hash)

      [format_rule_error(value)]
    end

    def falsy_scalar?(value)
      value.nil? || value == false
    end

    def collection?(value)
      value.is_a?(Array) || value.is_a?(Set)
    end

    def collection_errors(value)
      return [] if value.empty?

      value.to_a.map { |item| format_rule_error(item) }
    end

    def hash_errors(value)
      return [] if value.empty?

      [format_rule_error(value)]
    end

    def format_rule_error(value)
      "Rule '#{rule_name}' returned: #{value.inspect}"
    end

    def rule_name
      @rule_name ||= query.to_s.split(".").last
    end
  end

  # Emits human-readable or JSON output.
  class OutcomeEmitter
    def initialize(stdout)
      @stdout = stdout
    end

    def emit(outcome, format: "text")
      return emit_json(outcome) if format == "json"

      emit_text(outcome)
    end

    private

    attr_reader :stdout

    def emit_json(outcome)
      stdout.puts(JSON.generate(outcome_payload(outcome)))
    end

    def emit_text(outcome)
      return stdout.puts("✓ Validation passed") if outcome.success?

      stdout.puts("✗ Validation failed:")
      outcome.errors.each { |error| stdout.puts("  - #{error}") }
    end

    def outcome_payload(outcome)
      return { success: true, result: normalize_json(outcome.value) } if outcome.success?

      { success: false, errors: outcome.errors }
    end

    def normalize_json(value)
      case value
      when Array
        value.map { |item| normalize_json(item) }
      when Hash
        value.transform_values { |item| normalize_json(item) }
      when Set
        value.to_a.map { |item| normalize_json(item) }
      else
        value
      end
    end
  end

  # Formats and emits CLI errors to stderr/stdout.
  class ErrorReporter
    def initialize(stdout:, stderr:)
      @stdout = stdout
      @stderr = stderr
    end

    def error(message, parser = nil, format: "text")
      return error_json(message) if format == "json"

      stderr.puts("Error: #{message}")
      stderr.puts(parser) if parser
    end

    def rego_error(error, format: "text")
      return rego_error_json(error) if format == "json"

      rego_error_text(error)
    end

    private

    attr_reader :stdout, :stderr

    def error_json(message)
      stdout.puts(JSON.generate(error_payload(message, type: "CLIError")))
    end

    def error_payload(message, type:, location: nil)
      payload = { success: false, error: message, type: type }
      return payload unless location

      payload.merge(
        location: location.to_s,
        line: location.line,
        column: location.column
      )
    end

    def rego_error_json(error)
      stdout.puts(JSON.generate(rego_error_payload(error)))
    end

    def rego_error_text(error)
      location = error_location(error)
      stderr.puts("Error: #{error.message}")
      stderr.puts("  at #{location}") if location
    end

    def rego_error_payload(error)
      location = error_location(error)
      error_payload(error.message, type: error.class.name, location: location)
    end

    def error_location(error)
      error.respond_to?(:location) ? error.location : nil
    end
  end
end

exit RegoValidate::CLI.new(ARGV).run
